// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: overall_system_nrtstate.proto
#define PROTOBUF_USE_DLLS
#ifndef GOOGLE_PROTOBUF_INCLUDED_overall_5fsystem_5fnrtstate_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_overall_5fsystem_5fnrtstate_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_overall_5fsystem_5fnrtstate_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_overall_5fsystem_5fnrtstate_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_overall_5fsystem_5fnrtstate_2eproto;
namespace system_nrtstate {
class Controller;
struct ControllerDefaultTypeInternal;
extern ControllerDefaultTypeInternal _Controller_default_instance_;
class Header;
struct HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class Interface;
struct InterfaceDefaultTypeInternal;
extern InterfaceDefaultTypeInternal _Interface_default_instance_;
class Joint;
struct JointDefaultTypeInternal;
extern JointDefaultTypeInternal _Joint_default_instance_;
class Load;
struct LoadDefaultTypeInternal;
extern LoadDefaultTypeInternal _Load_default_instance_;
class Model;
struct ModelDefaultTypeInternal;
extern ModelDefaultTypeInternal _Model_default_instance_;
class Point;
struct PointDefaultTypeInternal;
extern PointDefaultTypeInternal _Point_default_instance_;
class Sensor;
struct SensorDefaultTypeInternal;
extern SensorDefaultTypeInternal _Sensor_default_instance_;
class Slave;
struct SlaveDefaultTypeInternal;
extern SlaveDefaultTypeInternal _Slave_default_instance_;
class Subsystem;
struct SubsystemDefaultTypeInternal;
extern SubsystemDefaultTypeInternal _Subsystem_default_instance_;
class SystemNrtState;
struct SystemNrtStateDefaultTypeInternal;
extern SystemNrtStateDefaultTypeInternal _SystemNrtState_default_instance_;
class Tool;
struct ToolDefaultTypeInternal;
extern ToolDefaultTypeInternal _Tool_default_instance_;
class Wobj;
struct WobjDefaultTypeInternal;
extern WobjDefaultTypeInternal _Wobj_default_instance_;
}  // namespace system_nrtstate
PROTOBUF_NAMESPACE_OPEN
template<> ::system_nrtstate::Controller* Arena::CreateMaybeMessage<::system_nrtstate::Controller>(Arena*);
template<> ::system_nrtstate::Header* Arena::CreateMaybeMessage<::system_nrtstate::Header>(Arena*);
template<> ::system_nrtstate::Interface* Arena::CreateMaybeMessage<::system_nrtstate::Interface>(Arena*);
template<> ::system_nrtstate::Joint* Arena::CreateMaybeMessage<::system_nrtstate::Joint>(Arena*);
template<> ::system_nrtstate::Load* Arena::CreateMaybeMessage<::system_nrtstate::Load>(Arena*);
template<> ::system_nrtstate::Model* Arena::CreateMaybeMessage<::system_nrtstate::Model>(Arena*);
template<> ::system_nrtstate::Point* Arena::CreateMaybeMessage<::system_nrtstate::Point>(Arena*);
template<> ::system_nrtstate::Sensor* Arena::CreateMaybeMessage<::system_nrtstate::Sensor>(Arena*);
template<> ::system_nrtstate::Slave* Arena::CreateMaybeMessage<::system_nrtstate::Slave>(Arena*);
template<> ::system_nrtstate::Subsystem* Arena::CreateMaybeMessage<::system_nrtstate::Subsystem>(Arena*);
template<> ::system_nrtstate::SystemNrtState* Arena::CreateMaybeMessage<::system_nrtstate::SystemNrtState>(Arena*);
template<> ::system_nrtstate::Tool* Arena::CreateMaybeMessage<::system_nrtstate::Tool>(Arena*);
template<> ::system_nrtstate::Wobj* Arena::CreateMaybeMessage<::system_nrtstate::Wobj>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace system_nrtstate {

// ===================================================================

class Header final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:system_nrtstate.Header) */ {
 public:
  inline Header() : Header(nullptr) {}
  ~Header() override;
  explicit PROTOBUF_CONSTEXPR Header(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Header(const Header& from);
  Header(Header&& from) noexcept
    : Header() {
    *this = ::std::move(from);
  }

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }
  inline Header& operator=(Header&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Header& default_instance() {
    return *internal_default_instance();
  }
  static inline const Header* internal_default_instance() {
    return reinterpret_cast<const Header*>(
               &_Header_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Header& a, Header& b) {
    a.Swap(&b);
  }
  inline void Swap(Header* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Header* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Header* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Header>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Header& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Header& from) {
    Header::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Header* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "system_nrtstate.Header";
  }
  protected:
  explicit Header(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
    kFrameIdFieldNumber = 2,
  };
  // int64 timestamp = 1;
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // int64 frame_id = 2;
  void clear_frame_id();
  int64_t frame_id() const;
  void set_frame_id(int64_t value);
  private:
  int64_t _internal_frame_id() const;
  void _internal_set_frame_id(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:system_nrtstate.Header)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t timestamp_;
    int64_t frame_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_overall_5fsystem_5fnrtstate_2eproto;
};
// -------------------------------------------------------------------

class Slave final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:system_nrtstate.Slave) */ {
 public:
  inline Slave() : Slave(nullptr) {}
  ~Slave() override;
  explicit PROTOBUF_CONSTEXPR Slave(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Slave(const Slave& from);
  Slave(Slave&& from) noexcept
    : Slave() {
    *this = ::std::move(from);
  }

  inline Slave& operator=(const Slave& from) {
    CopyFrom(from);
    return *this;
  }
  inline Slave& operator=(Slave&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Slave& default_instance() {
    return *internal_default_instance();
  }
  static inline const Slave* internal_default_instance() {
    return reinterpret_cast<const Slave*>(
               &_Slave_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Slave& a, Slave& b) {
    a.Swap(&b);
  }
  inline void Swap(Slave* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Slave* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Slave* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Slave>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Slave& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Slave& from) {
    Slave::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Slave* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "system_nrtstate.Slave";
  }
  protected:
  explicit Slave(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSlaveNameFieldNumber = 1,
    kPhyIdFieldNumber = 2,
    kAliasFieldNumber = 3,
    kSlaveStateFieldNumber = 4,
    kIsOnlineFieldNumber = 5,
    kIsVirtualFieldNumber = 6,
    kIsErrorFieldNumber = 7,
  };
  // string slave_name = 1;
  void clear_slave_name();
  const std::string& slave_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_slave_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_slave_name();
  PROTOBUF_NODISCARD std::string* release_slave_name();
  void set_allocated_slave_name(std::string* slave_name);
  private:
  const std::string& _internal_slave_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_slave_name(const std::string& value);
  std::string* _internal_mutable_slave_name();
  public:

  // int32 phy_id = 2;
  void clear_phy_id();
  int32_t phy_id() const;
  void set_phy_id(int32_t value);
  private:
  int32_t _internal_phy_id() const;
  void _internal_set_phy_id(int32_t value);
  public:

  // int32 alias = 3;
  void clear_alias();
  int32_t alias() const;
  void set_alias(int32_t value);
  private:
  int32_t _internal_alias() const;
  void _internal_set_alias(int32_t value);
  public:

  // int32 slave_state = 4;
  void clear_slave_state();
  int32_t slave_state() const;
  void set_slave_state(int32_t value);
  private:
  int32_t _internal_slave_state() const;
  void _internal_set_slave_state(int32_t value);
  public:

  // int32 is_online = 5;
  void clear_is_online();
  int32_t is_online() const;
  void set_is_online(int32_t value);
  private:
  int32_t _internal_is_online() const;
  void _internal_set_is_online(int32_t value);
  public:

  // bool is_virtual = 6;
  void clear_is_virtual();
  bool is_virtual() const;
  void set_is_virtual(bool value);
  private:
  bool _internal_is_virtual() const;
  void _internal_set_is_virtual(bool value);
  public:

  // bool is_error = 7;
  void clear_is_error();
  bool is_error() const;
  void set_is_error(bool value);
  private:
  bool _internal_is_error() const;
  void _internal_set_is_error(bool value);
  public:

  // @@protoc_insertion_point(class_scope:system_nrtstate.Slave)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr slave_name_;
    int32_t phy_id_;
    int32_t alias_;
    int32_t slave_state_;
    int32_t is_online_;
    bool is_virtual_;
    bool is_error_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_overall_5fsystem_5fnrtstate_2eproto;
};
// -------------------------------------------------------------------

class Controller final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:system_nrtstate.Controller) */ {
 public:
  inline Controller() : Controller(nullptr) {}
  ~Controller() override;
  explicit PROTOBUF_CONSTEXPR Controller(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Controller(const Controller& from);
  Controller(Controller&& from) noexcept
    : Controller() {
    *this = ::std::move(from);
  }

  inline Controller& operator=(const Controller& from) {
    CopyFrom(from);
    return *this;
  }
  inline Controller& operator=(Controller&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Controller& default_instance() {
    return *internal_default_instance();
  }
  static inline const Controller* internal_default_instance() {
    return reinterpret_cast<const Controller*>(
               &_Controller_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Controller& a, Controller& b) {
    a.Swap(&b);
  }
  inline void Swap(Controller* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Controller* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Controller* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Controller>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Controller& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Controller& from) {
    Controller::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Controller* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "system_nrtstate.Controller";
  }
  protected:
  explicit Controller(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSlaveFieldNumber = 1,
  };
  // repeated .system_nrtstate.Slave slave = 1;
  int slave_size() const;
  private:
  int _internal_slave_size() const;
  public:
  void clear_slave();
  ::system_nrtstate::Slave* mutable_slave(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_nrtstate::Slave >*
      mutable_slave();
  private:
  const ::system_nrtstate::Slave& _internal_slave(int index) const;
  ::system_nrtstate::Slave* _internal_add_slave();
  public:
  const ::system_nrtstate::Slave& slave(int index) const;
  ::system_nrtstate::Slave* add_slave();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_nrtstate::Slave >&
      slave() const;

  // @@protoc_insertion_point(class_scope:system_nrtstate.Controller)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_nrtstate::Slave > slave_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_overall_5fsystem_5fnrtstate_2eproto;
};
// -------------------------------------------------------------------

class Joint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:system_nrtstate.Joint) */ {
 public:
  inline Joint() : Joint(nullptr) {}
  ~Joint() override;
  explicit PROTOBUF_CONSTEXPR Joint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Joint(const Joint& from);
  Joint(Joint&& from) noexcept
    : Joint() {
    *this = ::std::move(from);
  }

  inline Joint& operator=(const Joint& from) {
    CopyFrom(from);
    return *this;
  }
  inline Joint& operator=(Joint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Joint& default_instance() {
    return *internal_default_instance();
  }
  static inline const Joint* internal_default_instance() {
    return reinterpret_cast<const Joint*>(
               &_Joint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Joint& a, Joint& b) {
    a.Swap(&b);
  }
  inline void Swap(Joint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Joint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Joint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Joint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Joint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Joint& from) {
    Joint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Joint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "system_nrtstate.Joint";
  }
  protected:
  explicit Joint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaxPositionFieldNumber = 1,
    kMinPositionFieldNumber = 2,
    kMaxVelFieldNumber = 3,
    kMinVelFieldNumber = 4,
    kMaxAccFieldNumber = 5,
    kMinAccFieldNumber = 6,
    kMaxCollisionTorqueFieldNumber = 7,
  };
  // double max_position = 1;
  void clear_max_position();
  double max_position() const;
  void set_max_position(double value);
  private:
  double _internal_max_position() const;
  void _internal_set_max_position(double value);
  public:

  // double min_position = 2;
  void clear_min_position();
  double min_position() const;
  void set_min_position(double value);
  private:
  double _internal_min_position() const;
  void _internal_set_min_position(double value);
  public:

  // double max_vel = 3;
  void clear_max_vel();
  double max_vel() const;
  void set_max_vel(double value);
  private:
  double _internal_max_vel() const;
  void _internal_set_max_vel(double value);
  public:

  // double min_vel = 4;
  void clear_min_vel();
  double min_vel() const;
  void set_min_vel(double value);
  private:
  double _internal_min_vel() const;
  void _internal_set_min_vel(double value);
  public:

  // double max_acc = 5;
  void clear_max_acc();
  double max_acc() const;
  void set_max_acc(double value);
  private:
  double _internal_max_acc() const;
  void _internal_set_max_acc(double value);
  public:

  // double min_acc = 6;
  void clear_min_acc();
  double min_acc() const;
  void set_min_acc(double value);
  private:
  double _internal_min_acc() const;
  void _internal_set_min_acc(double value);
  public:

  // double max_collision_torque = 7;
  void clear_max_collision_torque();
  double max_collision_torque() const;
  void set_max_collision_torque(double value);
  private:
  double _internal_max_collision_torque() const;
  void _internal_set_max_collision_torque(double value);
  public:

  // @@protoc_insertion_point(class_scope:system_nrtstate.Joint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double max_position_;
    double min_position_;
    double max_vel_;
    double min_vel_;
    double max_acc_;
    double min_acc_;
    double max_collision_torque_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_overall_5fsystem_5fnrtstate_2eproto;
};
// -------------------------------------------------------------------

class Tool final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:system_nrtstate.Tool) */ {
 public:
  inline Tool() : Tool(nullptr) {}
  ~Tool() override;
  explicit PROTOBUF_CONSTEXPR Tool(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Tool(const Tool& from);
  Tool(Tool&& from) noexcept
    : Tool() {
    *this = ::std::move(from);
  }

  inline Tool& operator=(const Tool& from) {
    CopyFrom(from);
    return *this;
  }
  inline Tool& operator=(Tool&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Tool& default_instance() {
    return *internal_default_instance();
  }
  static inline const Tool* internal_default_instance() {
    return reinterpret_cast<const Tool*>(
               &_Tool_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Tool& a, Tool& b) {
    a.Swap(&b);
  }
  inline void Swap(Tool* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Tool* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Tool* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Tool>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Tool& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Tool& from) {
    Tool::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tool* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "system_nrtstate.Tool";
  }
  protected:
  explicit Tool(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kToolNameFieldNumber = 1,
  };
  // repeated double data = 2;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  private:
  double _internal_data(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_data() const;
  void _internal_add_data(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_data();
  public:
  double data(int index) const;
  void set_data(int index, double value);
  void add_data(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_data();

  // string tool_name = 1;
  void clear_tool_name();
  const std::string& tool_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tool_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tool_name();
  PROTOBUF_NODISCARD std::string* release_tool_name();
  void set_allocated_tool_name(std::string* tool_name);
  private:
  const std::string& _internal_tool_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tool_name(const std::string& value);
  std::string* _internal_mutable_tool_name();
  public:

  // @@protoc_insertion_point(class_scope:system_nrtstate.Tool)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tool_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_overall_5fsystem_5fnrtstate_2eproto;
};
// -------------------------------------------------------------------

class Wobj final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:system_nrtstate.Wobj) */ {
 public:
  inline Wobj() : Wobj(nullptr) {}
  ~Wobj() override;
  explicit PROTOBUF_CONSTEXPR Wobj(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Wobj(const Wobj& from);
  Wobj(Wobj&& from) noexcept
    : Wobj() {
    *this = ::std::move(from);
  }

  inline Wobj& operator=(const Wobj& from) {
    CopyFrom(from);
    return *this;
  }
  inline Wobj& operator=(Wobj&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Wobj& default_instance() {
    return *internal_default_instance();
  }
  static inline const Wobj* internal_default_instance() {
    return reinterpret_cast<const Wobj*>(
               &_Wobj_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Wobj& a, Wobj& b) {
    a.Swap(&b);
  }
  inline void Swap(Wobj* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Wobj* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Wobj* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Wobj>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Wobj& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Wobj& from) {
    Wobj::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Wobj* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "system_nrtstate.Wobj";
  }
  protected:
  explicit Wobj(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kWobjNameFieldNumber = 1,
  };
  // repeated double data = 2;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  private:
  double _internal_data(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_data() const;
  void _internal_add_data(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_data();
  public:
  double data(int index) const;
  void set_data(int index, double value);
  void add_data(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_data();

  // string wobj_name = 1;
  void clear_wobj_name();
  const std::string& wobj_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_wobj_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_wobj_name();
  PROTOBUF_NODISCARD std::string* release_wobj_name();
  void set_allocated_wobj_name(std::string* wobj_name);
  private:
  const std::string& _internal_wobj_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_wobj_name(const std::string& value);
  std::string* _internal_mutable_wobj_name();
  public:

  // @@protoc_insertion_point(class_scope:system_nrtstate.Wobj)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr wobj_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_overall_5fsystem_5fnrtstate_2eproto;
};
// -------------------------------------------------------------------

class Load final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:system_nrtstate.Load) */ {
 public:
  inline Load() : Load(nullptr) {}
  ~Load() override;
  explicit PROTOBUF_CONSTEXPR Load(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Load(const Load& from);
  Load(Load&& from) noexcept
    : Load() {
    *this = ::std::move(from);
  }

  inline Load& operator=(const Load& from) {
    CopyFrom(from);
    return *this;
  }
  inline Load& operator=(Load&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Load& default_instance() {
    return *internal_default_instance();
  }
  static inline const Load* internal_default_instance() {
    return reinterpret_cast<const Load*>(
               &_Load_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Load& a, Load& b) {
    a.Swap(&b);
  }
  inline void Swap(Load* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Load* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Load* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Load>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Load& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Load& from) {
    Load::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Load* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "system_nrtstate.Load";
  }
  protected:
  explicit Load(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kLoadNameFieldNumber = 1,
  };
  // repeated double data = 2;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  private:
  double _internal_data(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_data() const;
  void _internal_add_data(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_data();
  public:
  double data(int index) const;
  void set_data(int index, double value);
  void add_data(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_data();

  // string load_name = 1;
  void clear_load_name();
  const std::string& load_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_load_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_load_name();
  PROTOBUF_NODISCARD std::string* release_load_name();
  void set_allocated_load_name(std::string* load_name);
  private:
  const std::string& _internal_load_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_load_name(const std::string& value);
  std::string* _internal_mutable_load_name();
  public:

  // @@protoc_insertion_point(class_scope:system_nrtstate.Load)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr load_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_overall_5fsystem_5fnrtstate_2eproto;
};
// -------------------------------------------------------------------

class Point final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:system_nrtstate.Point) */ {
 public:
  inline Point() : Point(nullptr) {}
  ~Point() override;
  explicit PROTOBUF_CONSTEXPR Point(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Point(const Point& from);
  Point(Point&& from) noexcept
    : Point() {
    *this = ::std::move(from);
  }

  inline Point& operator=(const Point& from) {
    CopyFrom(from);
    return *this;
  }
  inline Point& operator=(Point&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Point& default_instance() {
    return *internal_default_instance();
  }
  static inline const Point* internal_default_instance() {
    return reinterpret_cast<const Point*>(
               &_Point_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Point& a, Point& b) {
    a.Swap(&b);
  }
  inline void Swap(Point* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Point* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Point* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Point>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Point& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Point& from) {
    Point::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Point* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "system_nrtstate.Point";
  }
  protected:
  explicit Point(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRobottargetFieldNumber = 4,
    kJointtargetFieldNumber = 5,
    kPointNameFieldNumber = 1,
    kToolFieldNumber = 2,
    kWobjFieldNumber = 3,
  };
  // repeated double robottarget = 4;
  int robottarget_size() const;
  private:
  int _internal_robottarget_size() const;
  public:
  void clear_robottarget();
  private:
  double _internal_robottarget(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_robottarget() const;
  void _internal_add_robottarget(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_robottarget();
  public:
  double robottarget(int index) const;
  void set_robottarget(int index, double value);
  void add_robottarget(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      robottarget() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_robottarget();

  // repeated double jointtarget = 5;
  int jointtarget_size() const;
  private:
  int _internal_jointtarget_size() const;
  public:
  void clear_jointtarget();
  private:
  double _internal_jointtarget(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_jointtarget() const;
  void _internal_add_jointtarget(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_jointtarget();
  public:
  double jointtarget(int index) const;
  void set_jointtarget(int index, double value);
  void add_jointtarget(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      jointtarget() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_jointtarget();

  // string point_name = 1;
  void clear_point_name();
  const std::string& point_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_point_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_point_name();
  PROTOBUF_NODISCARD std::string* release_point_name();
  void set_allocated_point_name(std::string* point_name);
  private:
  const std::string& _internal_point_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_point_name(const std::string& value);
  std::string* _internal_mutable_point_name();
  public:

  // .system_nrtstate.Tool tool = 2;
  bool has_tool() const;
  private:
  bool _internal_has_tool() const;
  public:
  void clear_tool();
  const ::system_nrtstate::Tool& tool() const;
  PROTOBUF_NODISCARD ::system_nrtstate::Tool* release_tool();
  ::system_nrtstate::Tool* mutable_tool();
  void set_allocated_tool(::system_nrtstate::Tool* tool);
  private:
  const ::system_nrtstate::Tool& _internal_tool() const;
  ::system_nrtstate::Tool* _internal_mutable_tool();
  public:
  void unsafe_arena_set_allocated_tool(
      ::system_nrtstate::Tool* tool);
  ::system_nrtstate::Tool* unsafe_arena_release_tool();

  // .system_nrtstate.Wobj wobj = 3;
  bool has_wobj() const;
  private:
  bool _internal_has_wobj() const;
  public:
  void clear_wobj();
  const ::system_nrtstate::Wobj& wobj() const;
  PROTOBUF_NODISCARD ::system_nrtstate::Wobj* release_wobj();
  ::system_nrtstate::Wobj* mutable_wobj();
  void set_allocated_wobj(::system_nrtstate::Wobj* wobj);
  private:
  const ::system_nrtstate::Wobj& _internal_wobj() const;
  ::system_nrtstate::Wobj* _internal_mutable_wobj();
  public:
  void unsafe_arena_set_allocated_wobj(
      ::system_nrtstate::Wobj* wobj);
  ::system_nrtstate::Wobj* unsafe_arena_release_wobj();

  // @@protoc_insertion_point(class_scope:system_nrtstate.Point)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > robottarget_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > jointtarget_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr point_name_;
    ::system_nrtstate::Tool* tool_;
    ::system_nrtstate::Wobj* wobj_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_overall_5fsystem_5fnrtstate_2eproto;
};
// -------------------------------------------------------------------

class Model final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:system_nrtstate.Model) */ {
 public:
  inline Model() : Model(nullptr) {}
  ~Model() override;
  explicit PROTOBUF_CONSTEXPR Model(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Model(const Model& from);
  Model(Model&& from) noexcept
    : Model() {
    *this = ::std::move(from);
  }

  inline Model& operator=(const Model& from) {
    CopyFrom(from);
    return *this;
  }
  inline Model& operator=(Model&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Model& default_instance() {
    return *internal_default_instance();
  }
  static inline const Model* internal_default_instance() {
    return reinterpret_cast<const Model*>(
               &_Model_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Model& a, Model& b) {
    a.Swap(&b);
  }
  inline void Swap(Model* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Model* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Model* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Model>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Model& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Model& from) {
    Model::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Model* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "system_nrtstate.Model";
  }
  protected:
  explicit Model(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJointFieldNumber = 3,
    kToolsFieldNumber = 5,
    kWobjsFieldNumber = 6,
    kLoadsFieldNumber = 7,
    kTeachPointsFieldNumber = 8,
    kModelNameFieldNumber = 1,
    kModelTypeFieldNumber = 2,
  };
  // repeated .system_nrtstate.Joint joint = 3;
  int joint_size() const;
  private:
  int _internal_joint_size() const;
  public:
  void clear_joint();
  ::system_nrtstate::Joint* mutable_joint(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_nrtstate::Joint >*
      mutable_joint();
  private:
  const ::system_nrtstate::Joint& _internal_joint(int index) const;
  ::system_nrtstate::Joint* _internal_add_joint();
  public:
  const ::system_nrtstate::Joint& joint(int index) const;
  ::system_nrtstate::Joint* add_joint();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_nrtstate::Joint >&
      joint() const;

  // repeated .system_nrtstate.Tool tools = 5;
  int tools_size() const;
  private:
  int _internal_tools_size() const;
  public:
  void clear_tools();
  ::system_nrtstate::Tool* mutable_tools(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_nrtstate::Tool >*
      mutable_tools();
  private:
  const ::system_nrtstate::Tool& _internal_tools(int index) const;
  ::system_nrtstate::Tool* _internal_add_tools();
  public:
  const ::system_nrtstate::Tool& tools(int index) const;
  ::system_nrtstate::Tool* add_tools();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_nrtstate::Tool >&
      tools() const;

  // repeated .system_nrtstate.Wobj wobjs = 6;
  int wobjs_size() const;
  private:
  int _internal_wobjs_size() const;
  public:
  void clear_wobjs();
  ::system_nrtstate::Wobj* mutable_wobjs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_nrtstate::Wobj >*
      mutable_wobjs();
  private:
  const ::system_nrtstate::Wobj& _internal_wobjs(int index) const;
  ::system_nrtstate::Wobj* _internal_add_wobjs();
  public:
  const ::system_nrtstate::Wobj& wobjs(int index) const;
  ::system_nrtstate::Wobj* add_wobjs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_nrtstate::Wobj >&
      wobjs() const;

  // repeated .system_nrtstate.Load loads = 7;
  int loads_size() const;
  private:
  int _internal_loads_size() const;
  public:
  void clear_loads();
  ::system_nrtstate::Load* mutable_loads(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_nrtstate::Load >*
      mutable_loads();
  private:
  const ::system_nrtstate::Load& _internal_loads(int index) const;
  ::system_nrtstate::Load* _internal_add_loads();
  public:
  const ::system_nrtstate::Load& loads(int index) const;
  ::system_nrtstate::Load* add_loads();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_nrtstate::Load >&
      loads() const;

  // repeated .system_nrtstate.Point teach_points = 8;
  int teach_points_size() const;
  private:
  int _internal_teach_points_size() const;
  public:
  void clear_teach_points();
  ::system_nrtstate::Point* mutable_teach_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_nrtstate::Point >*
      mutable_teach_points();
  private:
  const ::system_nrtstate::Point& _internal_teach_points(int index) const;
  ::system_nrtstate::Point* _internal_add_teach_points();
  public:
  const ::system_nrtstate::Point& teach_points(int index) const;
  ::system_nrtstate::Point* add_teach_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_nrtstate::Point >&
      teach_points() const;

  // string model_name = 1;
  void clear_model_name();
  const std::string& model_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_name();
  PROTOBUF_NODISCARD std::string* release_model_name();
  void set_allocated_model_name(std::string* model_name);
  private:
  const std::string& _internal_model_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_name(const std::string& value);
  std::string* _internal_mutable_model_name();
  public:

  // string model_type = 2;
  void clear_model_type();
  const std::string& model_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_type();
  PROTOBUF_NODISCARD std::string* release_model_type();
  void set_allocated_model_type(std::string* model_type);
  private:
  const std::string& _internal_model_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_type(const std::string& value);
  std::string* _internal_mutable_model_type();
  public:

  // @@protoc_insertion_point(class_scope:system_nrtstate.Model)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_nrtstate::Joint > joint_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_nrtstate::Tool > tools_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_nrtstate::Wobj > wobjs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_nrtstate::Load > loads_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_nrtstate::Point > teach_points_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_overall_5fsystem_5fnrtstate_2eproto;
};
// -------------------------------------------------------------------

class Subsystem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:system_nrtstate.Subsystem) */ {
 public:
  inline Subsystem() : Subsystem(nullptr) {}
  ~Subsystem() override;
  explicit PROTOBUF_CONSTEXPR Subsystem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Subsystem(const Subsystem& from);
  Subsystem(Subsystem&& from) noexcept
    : Subsystem() {
    *this = ::std::move(from);
  }

  inline Subsystem& operator=(const Subsystem& from) {
    CopyFrom(from);
    return *this;
  }
  inline Subsystem& operator=(Subsystem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Subsystem& default_instance() {
    return *internal_default_instance();
  }
  static inline const Subsystem* internal_default_instance() {
    return reinterpret_cast<const Subsystem*>(
               &_Subsystem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Subsystem& a, Subsystem& b) {
    a.Swap(&b);
  }
  inline void Swap(Subsystem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Subsystem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Subsystem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Subsystem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Subsystem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Subsystem& from) {
    Subsystem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Subsystem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "system_nrtstate.Subsystem";
  }
  protected:
  explicit Subsystem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubsystemNameFieldNumber = 1,
    kIdFieldNumber = 2,
    kStateFieldNumber = 3,
  };
  // string subsystem_name = 1;
  void clear_subsystem_name();
  const std::string& subsystem_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_subsystem_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_subsystem_name();
  PROTOBUF_NODISCARD std::string* release_subsystem_name();
  void set_allocated_subsystem_name(std::string* subsystem_name);
  private:
  const std::string& _internal_subsystem_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subsystem_name(const std::string& value);
  std::string* _internal_mutable_subsystem_name();
  public:

  // int32 id = 2;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // int32 state = 3;
  void clear_state();
  int32_t state() const;
  void set_state(int32_t value);
  private:
  int32_t _internal_state() const;
  void _internal_set_state(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:system_nrtstate.Subsystem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subsystem_name_;
    int32_t id_;
    int32_t state_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_overall_5fsystem_5fnrtstate_2eproto;
};
// -------------------------------------------------------------------

class Sensor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:system_nrtstate.Sensor) */ {
 public:
  inline Sensor() : Sensor(nullptr) {}
  ~Sensor() override;
  explicit PROTOBUF_CONSTEXPR Sensor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Sensor(const Sensor& from);
  Sensor(Sensor&& from) noexcept
    : Sensor() {
    *this = ::std::move(from);
  }

  inline Sensor& operator=(const Sensor& from) {
    CopyFrom(from);
    return *this;
  }
  inline Sensor& operator=(Sensor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Sensor& default_instance() {
    return *internal_default_instance();
  }
  static inline const Sensor* internal_default_instance() {
    return reinterpret_cast<const Sensor*>(
               &_Sensor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Sensor& a, Sensor& b) {
    a.Swap(&b);
  }
  inline void Swap(Sensor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Sensor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Sensor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Sensor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Sensor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Sensor& from) {
    Sensor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Sensor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "system_nrtstate.Sensor";
  }
  protected:
  explicit Sensor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSensorNameFieldNumber = 1,
    kIdFieldNumber = 2,
    kStateFieldNumber = 3,
  };
  // string sensor_name = 1;
  void clear_sensor_name();
  const std::string& sensor_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sensor_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sensor_name();
  PROTOBUF_NODISCARD std::string* release_sensor_name();
  void set_allocated_sensor_name(std::string* sensor_name);
  private:
  const std::string& _internal_sensor_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sensor_name(const std::string& value);
  std::string* _internal_mutable_sensor_name();
  public:

  // int32 id = 2;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // int32 state = 3;
  void clear_state();
  int32_t state() const;
  void set_state(int32_t value);
  private:
  int32_t _internal_state() const;
  void _internal_set_state(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:system_nrtstate.Sensor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sensor_name_;
    int32_t id_;
    int32_t state_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_overall_5fsystem_5fnrtstate_2eproto;
};
// -------------------------------------------------------------------

class Interface final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:system_nrtstate.Interface) */ {
 public:
  inline Interface() : Interface(nullptr) {}
  ~Interface() override;
  explicit PROTOBUF_CONSTEXPR Interface(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Interface(const Interface& from);
  Interface(Interface&& from) noexcept
    : Interface() {
    *this = ::std::move(from);
  }

  inline Interface& operator=(const Interface& from) {
    CopyFrom(from);
    return *this;
  }
  inline Interface& operator=(Interface&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Interface& default_instance() {
    return *internal_default_instance();
  }
  static inline const Interface* internal_default_instance() {
    return reinterpret_cast<const Interface*>(
               &_Interface_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Interface& a, Interface& b) {
    a.Swap(&b);
  }
  inline void Swap(Interface* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Interface* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Interface* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Interface>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Interface& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Interface& from) {
    Interface::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Interface* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "system_nrtstate.Interface";
  }
  protected:
  explicit Interface(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInterfaceNameFieldNumber = 1,
    kIdFieldNumber = 2,
    kStateFieldNumber = 3,
  };
  // string interface_name = 1;
  void clear_interface_name();
  const std::string& interface_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_interface_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_interface_name();
  PROTOBUF_NODISCARD std::string* release_interface_name();
  void set_allocated_interface_name(std::string* interface_name);
  private:
  const std::string& _internal_interface_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_interface_name(const std::string& value);
  std::string* _internal_mutable_interface_name();
  public:

  // int32 id = 2;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // int32 state = 3;
  void clear_state();
  int32_t state() const;
  void set_state(int32_t value);
  private:
  int32_t _internal_state() const;
  void _internal_set_state(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:system_nrtstate.Interface)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr interface_name_;
    int32_t id_;
    int32_t state_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_overall_5fsystem_5fnrtstate_2eproto;
};
// -------------------------------------------------------------------

class SystemNrtState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:system_nrtstate.SystemNrtState) */ {
 public:
  inline SystemNrtState() : SystemNrtState(nullptr) {}
  ~SystemNrtState() override;
  explicit PROTOBUF_CONSTEXPR SystemNrtState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SystemNrtState(const SystemNrtState& from);
  SystemNrtState(SystemNrtState&& from) noexcept
    : SystemNrtState() {
    *this = ::std::move(from);
  }

  inline SystemNrtState& operator=(const SystemNrtState& from) {
    CopyFrom(from);
    return *this;
  }
  inline SystemNrtState& operator=(SystemNrtState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SystemNrtState& default_instance() {
    return *internal_default_instance();
  }
  static inline const SystemNrtState* internal_default_instance() {
    return reinterpret_cast<const SystemNrtState*>(
               &_SystemNrtState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SystemNrtState& a, SystemNrtState& b) {
    a.Swap(&b);
  }
  inline void Swap(SystemNrtState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SystemNrtState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SystemNrtState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SystemNrtState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SystemNrtState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SystemNrtState& from) {
    SystemNrtState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SystemNrtState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "system_nrtstate.SystemNrtState";
  }
  protected:
  explicit SystemNrtState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelFieldNumber = 3,
    kSubsystemFieldNumber = 5,
    kSensorFieldNumber = 6,
    kInterfaceFieldNumber = 7,
    kHeadFieldNumber = 1,
    kControllerFieldNumber = 4,
    kSystemRunningStateFieldNumber = 2,
  };
  // repeated .system_nrtstate.Model model = 3;
  int model_size() const;
  private:
  int _internal_model_size() const;
  public:
  void clear_model();
  ::system_nrtstate::Model* mutable_model(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_nrtstate::Model >*
      mutable_model();
  private:
  const ::system_nrtstate::Model& _internal_model(int index) const;
  ::system_nrtstate::Model* _internal_add_model();
  public:
  const ::system_nrtstate::Model& model(int index) const;
  ::system_nrtstate::Model* add_model();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_nrtstate::Model >&
      model() const;

  // repeated .system_nrtstate.Subsystem subsystem = 5;
  int subsystem_size() const;
  private:
  int _internal_subsystem_size() const;
  public:
  void clear_subsystem();
  ::system_nrtstate::Subsystem* mutable_subsystem(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_nrtstate::Subsystem >*
      mutable_subsystem();
  private:
  const ::system_nrtstate::Subsystem& _internal_subsystem(int index) const;
  ::system_nrtstate::Subsystem* _internal_add_subsystem();
  public:
  const ::system_nrtstate::Subsystem& subsystem(int index) const;
  ::system_nrtstate::Subsystem* add_subsystem();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_nrtstate::Subsystem >&
      subsystem() const;

  // repeated .system_nrtstate.Sensor sensor = 6;
  int sensor_size() const;
  private:
  int _internal_sensor_size() const;
  public:
  void clear_sensor();
  ::system_nrtstate::Sensor* mutable_sensor(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_nrtstate::Sensor >*
      mutable_sensor();
  private:
  const ::system_nrtstate::Sensor& _internal_sensor(int index) const;
  ::system_nrtstate::Sensor* _internal_add_sensor();
  public:
  const ::system_nrtstate::Sensor& sensor(int index) const;
  ::system_nrtstate::Sensor* add_sensor();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_nrtstate::Sensor >&
      sensor() const;

  // repeated .system_nrtstate.Interface interface = 7;
  int interface_size() const;
  private:
  int _internal_interface_size() const;
  public:
  void clear_interface();
  ::system_nrtstate::Interface* mutable_interface(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_nrtstate::Interface >*
      mutable_interface();
  private:
  const ::system_nrtstate::Interface& _internal_interface(int index) const;
  ::system_nrtstate::Interface* _internal_add_interface();
  public:
  const ::system_nrtstate::Interface& interface(int index) const;
  ::system_nrtstate::Interface* add_interface();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_nrtstate::Interface >&
      interface() const;

  // .system_nrtstate.Header head = 1;
  bool has_head() const;
  private:
  bool _internal_has_head() const;
  public:
  void clear_head();
  const ::system_nrtstate::Header& head() const;
  PROTOBUF_NODISCARD ::system_nrtstate::Header* release_head();
  ::system_nrtstate::Header* mutable_head();
  void set_allocated_head(::system_nrtstate::Header* head);
  private:
  const ::system_nrtstate::Header& _internal_head() const;
  ::system_nrtstate::Header* _internal_mutable_head();
  public:
  void unsafe_arena_set_allocated_head(
      ::system_nrtstate::Header* head);
  ::system_nrtstate::Header* unsafe_arena_release_head();

  // .system_nrtstate.Controller controller = 4;
  bool has_controller() const;
  private:
  bool _internal_has_controller() const;
  public:
  void clear_controller();
  const ::system_nrtstate::Controller& controller() const;
  PROTOBUF_NODISCARD ::system_nrtstate::Controller* release_controller();
  ::system_nrtstate::Controller* mutable_controller();
  void set_allocated_controller(::system_nrtstate::Controller* controller);
  private:
  const ::system_nrtstate::Controller& _internal_controller() const;
  ::system_nrtstate::Controller* _internal_mutable_controller();
  public:
  void unsafe_arena_set_allocated_controller(
      ::system_nrtstate::Controller* controller);
  ::system_nrtstate::Controller* unsafe_arena_release_controller();

  // bool system_running_state = 2;
  void clear_system_running_state();
  bool system_running_state() const;
  void set_system_running_state(bool value);
  private:
  bool _internal_system_running_state() const;
  void _internal_set_system_running_state(bool value);
  public:

  // @@protoc_insertion_point(class_scope:system_nrtstate.SystemNrtState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_nrtstate::Model > model_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_nrtstate::Subsystem > subsystem_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_nrtstate::Sensor > sensor_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_nrtstate::Interface > interface_;
    ::system_nrtstate::Header* head_;
    ::system_nrtstate::Controller* controller_;
    bool system_running_state_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_overall_5fsystem_5fnrtstate_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Header

// int64 timestamp = 1;
inline void Header::clear_timestamp() {
  _impl_.timestamp_ = int64_t{0};
}
inline int64_t Header::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline int64_t Header::timestamp() const {
  // @@protoc_insertion_point(field_get:system_nrtstate.Header.timestamp)
  return _internal_timestamp();
}
inline void Header::_internal_set_timestamp(int64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void Header::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:system_nrtstate.Header.timestamp)
}

// int64 frame_id = 2;
inline void Header::clear_frame_id() {
  _impl_.frame_id_ = int64_t{0};
}
inline int64_t Header::_internal_frame_id() const {
  return _impl_.frame_id_;
}
inline int64_t Header::frame_id() const {
  // @@protoc_insertion_point(field_get:system_nrtstate.Header.frame_id)
  return _internal_frame_id();
}
inline void Header::_internal_set_frame_id(int64_t value) {
  
  _impl_.frame_id_ = value;
}
inline void Header::set_frame_id(int64_t value) {
  _internal_set_frame_id(value);
  // @@protoc_insertion_point(field_set:system_nrtstate.Header.frame_id)
}

// -------------------------------------------------------------------

// Slave

// string slave_name = 1;
inline void Slave::clear_slave_name() {
  _impl_.slave_name_.ClearToEmpty();
}
inline const std::string& Slave::slave_name() const {
  // @@protoc_insertion_point(field_get:system_nrtstate.Slave.slave_name)
  return _internal_slave_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Slave::set_slave_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.slave_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:system_nrtstate.Slave.slave_name)
}
inline std::string* Slave::mutable_slave_name() {
  std::string* _s = _internal_mutable_slave_name();
  // @@protoc_insertion_point(field_mutable:system_nrtstate.Slave.slave_name)
  return _s;
}
inline const std::string& Slave::_internal_slave_name() const {
  return _impl_.slave_name_.Get();
}
inline void Slave::_internal_set_slave_name(const std::string& value) {
  
  _impl_.slave_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Slave::_internal_mutable_slave_name() {
  
  return _impl_.slave_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Slave::release_slave_name() {
  // @@protoc_insertion_point(field_release:system_nrtstate.Slave.slave_name)
  return _impl_.slave_name_.Release();
}
inline void Slave::set_allocated_slave_name(std::string* slave_name) {
  if (slave_name != nullptr) {
    
  } else {
    
  }
  _impl_.slave_name_.SetAllocated(slave_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.slave_name_.IsDefault()) {
    _impl_.slave_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:system_nrtstate.Slave.slave_name)
}

// int32 phy_id = 2;
inline void Slave::clear_phy_id() {
  _impl_.phy_id_ = 0;
}
inline int32_t Slave::_internal_phy_id() const {
  return _impl_.phy_id_;
}
inline int32_t Slave::phy_id() const {
  // @@protoc_insertion_point(field_get:system_nrtstate.Slave.phy_id)
  return _internal_phy_id();
}
inline void Slave::_internal_set_phy_id(int32_t value) {
  
  _impl_.phy_id_ = value;
}
inline void Slave::set_phy_id(int32_t value) {
  _internal_set_phy_id(value);
  // @@protoc_insertion_point(field_set:system_nrtstate.Slave.phy_id)
}

// int32 alias = 3;
inline void Slave::clear_alias() {
  _impl_.alias_ = 0;
}
inline int32_t Slave::_internal_alias() const {
  return _impl_.alias_;
}
inline int32_t Slave::alias() const {
  // @@protoc_insertion_point(field_get:system_nrtstate.Slave.alias)
  return _internal_alias();
}
inline void Slave::_internal_set_alias(int32_t value) {
  
  _impl_.alias_ = value;
}
inline void Slave::set_alias(int32_t value) {
  _internal_set_alias(value);
  // @@protoc_insertion_point(field_set:system_nrtstate.Slave.alias)
}

// int32 slave_state = 4;
inline void Slave::clear_slave_state() {
  _impl_.slave_state_ = 0;
}
inline int32_t Slave::_internal_slave_state() const {
  return _impl_.slave_state_;
}
inline int32_t Slave::slave_state() const {
  // @@protoc_insertion_point(field_get:system_nrtstate.Slave.slave_state)
  return _internal_slave_state();
}
inline void Slave::_internal_set_slave_state(int32_t value) {
  
  _impl_.slave_state_ = value;
}
inline void Slave::set_slave_state(int32_t value) {
  _internal_set_slave_state(value);
  // @@protoc_insertion_point(field_set:system_nrtstate.Slave.slave_state)
}

// int32 is_online = 5;
inline void Slave::clear_is_online() {
  _impl_.is_online_ = 0;
}
inline int32_t Slave::_internal_is_online() const {
  return _impl_.is_online_;
}
inline int32_t Slave::is_online() const {
  // @@protoc_insertion_point(field_get:system_nrtstate.Slave.is_online)
  return _internal_is_online();
}
inline void Slave::_internal_set_is_online(int32_t value) {
  
  _impl_.is_online_ = value;
}
inline void Slave::set_is_online(int32_t value) {
  _internal_set_is_online(value);
  // @@protoc_insertion_point(field_set:system_nrtstate.Slave.is_online)
}

// bool is_virtual = 6;
inline void Slave::clear_is_virtual() {
  _impl_.is_virtual_ = false;
}
inline bool Slave::_internal_is_virtual() const {
  return _impl_.is_virtual_;
}
inline bool Slave::is_virtual() const {
  // @@protoc_insertion_point(field_get:system_nrtstate.Slave.is_virtual)
  return _internal_is_virtual();
}
inline void Slave::_internal_set_is_virtual(bool value) {
  
  _impl_.is_virtual_ = value;
}
inline void Slave::set_is_virtual(bool value) {
  _internal_set_is_virtual(value);
  // @@protoc_insertion_point(field_set:system_nrtstate.Slave.is_virtual)
}

// bool is_error = 7;
inline void Slave::clear_is_error() {
  _impl_.is_error_ = false;
}
inline bool Slave::_internal_is_error() const {
  return _impl_.is_error_;
}
inline bool Slave::is_error() const {
  // @@protoc_insertion_point(field_get:system_nrtstate.Slave.is_error)
  return _internal_is_error();
}
inline void Slave::_internal_set_is_error(bool value) {
  
  _impl_.is_error_ = value;
}
inline void Slave::set_is_error(bool value) {
  _internal_set_is_error(value);
  // @@protoc_insertion_point(field_set:system_nrtstate.Slave.is_error)
}

// -------------------------------------------------------------------

// Controller

// repeated .system_nrtstate.Slave slave = 1;
inline int Controller::_internal_slave_size() const {
  return _impl_.slave_.size();
}
inline int Controller::slave_size() const {
  return _internal_slave_size();
}
inline void Controller::clear_slave() {
  _impl_.slave_.Clear();
}
inline ::system_nrtstate::Slave* Controller::mutable_slave(int index) {
  // @@protoc_insertion_point(field_mutable:system_nrtstate.Controller.slave)
  return _impl_.slave_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_nrtstate::Slave >*
Controller::mutable_slave() {
  // @@protoc_insertion_point(field_mutable_list:system_nrtstate.Controller.slave)
  return &_impl_.slave_;
}
inline const ::system_nrtstate::Slave& Controller::_internal_slave(int index) const {
  return _impl_.slave_.Get(index);
}
inline const ::system_nrtstate::Slave& Controller::slave(int index) const {
  // @@protoc_insertion_point(field_get:system_nrtstate.Controller.slave)
  return _internal_slave(index);
}
inline ::system_nrtstate::Slave* Controller::_internal_add_slave() {
  return _impl_.slave_.Add();
}
inline ::system_nrtstate::Slave* Controller::add_slave() {
  ::system_nrtstate::Slave* _add = _internal_add_slave();
  // @@protoc_insertion_point(field_add:system_nrtstate.Controller.slave)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_nrtstate::Slave >&
Controller::slave() const {
  // @@protoc_insertion_point(field_list:system_nrtstate.Controller.slave)
  return _impl_.slave_;
}

// -------------------------------------------------------------------

// Joint

// double max_position = 1;
inline void Joint::clear_max_position() {
  _impl_.max_position_ = 0;
}
inline double Joint::_internal_max_position() const {
  return _impl_.max_position_;
}
inline double Joint::max_position() const {
  // @@protoc_insertion_point(field_get:system_nrtstate.Joint.max_position)
  return _internal_max_position();
}
inline void Joint::_internal_set_max_position(double value) {
  
  _impl_.max_position_ = value;
}
inline void Joint::set_max_position(double value) {
  _internal_set_max_position(value);
  // @@protoc_insertion_point(field_set:system_nrtstate.Joint.max_position)
}

// double min_position = 2;
inline void Joint::clear_min_position() {
  _impl_.min_position_ = 0;
}
inline double Joint::_internal_min_position() const {
  return _impl_.min_position_;
}
inline double Joint::min_position() const {
  // @@protoc_insertion_point(field_get:system_nrtstate.Joint.min_position)
  return _internal_min_position();
}
inline void Joint::_internal_set_min_position(double value) {
  
  _impl_.min_position_ = value;
}
inline void Joint::set_min_position(double value) {
  _internal_set_min_position(value);
  // @@protoc_insertion_point(field_set:system_nrtstate.Joint.min_position)
}

// double max_vel = 3;
inline void Joint::clear_max_vel() {
  _impl_.max_vel_ = 0;
}
inline double Joint::_internal_max_vel() const {
  return _impl_.max_vel_;
}
inline double Joint::max_vel() const {
  // @@protoc_insertion_point(field_get:system_nrtstate.Joint.max_vel)
  return _internal_max_vel();
}
inline void Joint::_internal_set_max_vel(double value) {
  
  _impl_.max_vel_ = value;
}
inline void Joint::set_max_vel(double value) {
  _internal_set_max_vel(value);
  // @@protoc_insertion_point(field_set:system_nrtstate.Joint.max_vel)
}

// double min_vel = 4;
inline void Joint::clear_min_vel() {
  _impl_.min_vel_ = 0;
}
inline double Joint::_internal_min_vel() const {
  return _impl_.min_vel_;
}
inline double Joint::min_vel() const {
  // @@protoc_insertion_point(field_get:system_nrtstate.Joint.min_vel)
  return _internal_min_vel();
}
inline void Joint::_internal_set_min_vel(double value) {
  
  _impl_.min_vel_ = value;
}
inline void Joint::set_min_vel(double value) {
  _internal_set_min_vel(value);
  // @@protoc_insertion_point(field_set:system_nrtstate.Joint.min_vel)
}

// double max_acc = 5;
inline void Joint::clear_max_acc() {
  _impl_.max_acc_ = 0;
}
inline double Joint::_internal_max_acc() const {
  return _impl_.max_acc_;
}
inline double Joint::max_acc() const {
  // @@protoc_insertion_point(field_get:system_nrtstate.Joint.max_acc)
  return _internal_max_acc();
}
inline void Joint::_internal_set_max_acc(double value) {
  
  _impl_.max_acc_ = value;
}
inline void Joint::set_max_acc(double value) {
  _internal_set_max_acc(value);
  // @@protoc_insertion_point(field_set:system_nrtstate.Joint.max_acc)
}

// double min_acc = 6;
inline void Joint::clear_min_acc() {
  _impl_.min_acc_ = 0;
}
inline double Joint::_internal_min_acc() const {
  return _impl_.min_acc_;
}
inline double Joint::min_acc() const {
  // @@protoc_insertion_point(field_get:system_nrtstate.Joint.min_acc)
  return _internal_min_acc();
}
inline void Joint::_internal_set_min_acc(double value) {
  
  _impl_.min_acc_ = value;
}
inline void Joint::set_min_acc(double value) {
  _internal_set_min_acc(value);
  // @@protoc_insertion_point(field_set:system_nrtstate.Joint.min_acc)
}

// double max_collision_torque = 7;
inline void Joint::clear_max_collision_torque() {
  _impl_.max_collision_torque_ = 0;
}
inline double Joint::_internal_max_collision_torque() const {
  return _impl_.max_collision_torque_;
}
inline double Joint::max_collision_torque() const {
  // @@protoc_insertion_point(field_get:system_nrtstate.Joint.max_collision_torque)
  return _internal_max_collision_torque();
}
inline void Joint::_internal_set_max_collision_torque(double value) {
  
  _impl_.max_collision_torque_ = value;
}
inline void Joint::set_max_collision_torque(double value) {
  _internal_set_max_collision_torque(value);
  // @@protoc_insertion_point(field_set:system_nrtstate.Joint.max_collision_torque)
}

// -------------------------------------------------------------------

// Tool

// string tool_name = 1;
inline void Tool::clear_tool_name() {
  _impl_.tool_name_.ClearToEmpty();
}
inline const std::string& Tool::tool_name() const {
  // @@protoc_insertion_point(field_get:system_nrtstate.Tool.tool_name)
  return _internal_tool_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Tool::set_tool_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tool_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:system_nrtstate.Tool.tool_name)
}
inline std::string* Tool::mutable_tool_name() {
  std::string* _s = _internal_mutable_tool_name();
  // @@protoc_insertion_point(field_mutable:system_nrtstate.Tool.tool_name)
  return _s;
}
inline const std::string& Tool::_internal_tool_name() const {
  return _impl_.tool_name_.Get();
}
inline void Tool::_internal_set_tool_name(const std::string& value) {
  
  _impl_.tool_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Tool::_internal_mutable_tool_name() {
  
  return _impl_.tool_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Tool::release_tool_name() {
  // @@protoc_insertion_point(field_release:system_nrtstate.Tool.tool_name)
  return _impl_.tool_name_.Release();
}
inline void Tool::set_allocated_tool_name(std::string* tool_name) {
  if (tool_name != nullptr) {
    
  } else {
    
  }
  _impl_.tool_name_.SetAllocated(tool_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tool_name_.IsDefault()) {
    _impl_.tool_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:system_nrtstate.Tool.tool_name)
}

// repeated double data = 2;
inline int Tool::_internal_data_size() const {
  return _impl_.data_.size();
}
inline int Tool::data_size() const {
  return _internal_data_size();
}
inline void Tool::clear_data() {
  _impl_.data_.Clear();
}
inline double Tool::_internal_data(int index) const {
  return _impl_.data_.Get(index);
}
inline double Tool::data(int index) const {
  // @@protoc_insertion_point(field_get:system_nrtstate.Tool.data)
  return _internal_data(index);
}
inline void Tool::set_data(int index, double value) {
  _impl_.data_.Set(index, value);
  // @@protoc_insertion_point(field_set:system_nrtstate.Tool.data)
}
inline void Tool::_internal_add_data(double value) {
  _impl_.data_.Add(value);
}
inline void Tool::add_data(double value) {
  _internal_add_data(value);
  // @@protoc_insertion_point(field_add:system_nrtstate.Tool.data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
Tool::_internal_data() const {
  return _impl_.data_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
Tool::data() const {
  // @@protoc_insertion_point(field_list:system_nrtstate.Tool.data)
  return _internal_data();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
Tool::_internal_mutable_data() {
  return &_impl_.data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
Tool::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:system_nrtstate.Tool.data)
  return _internal_mutable_data();
}

// -------------------------------------------------------------------

// Wobj

// string wobj_name = 1;
inline void Wobj::clear_wobj_name() {
  _impl_.wobj_name_.ClearToEmpty();
}
inline const std::string& Wobj::wobj_name() const {
  // @@protoc_insertion_point(field_get:system_nrtstate.Wobj.wobj_name)
  return _internal_wobj_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Wobj::set_wobj_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.wobj_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:system_nrtstate.Wobj.wobj_name)
}
inline std::string* Wobj::mutable_wobj_name() {
  std::string* _s = _internal_mutable_wobj_name();
  // @@protoc_insertion_point(field_mutable:system_nrtstate.Wobj.wobj_name)
  return _s;
}
inline const std::string& Wobj::_internal_wobj_name() const {
  return _impl_.wobj_name_.Get();
}
inline void Wobj::_internal_set_wobj_name(const std::string& value) {
  
  _impl_.wobj_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Wobj::_internal_mutable_wobj_name() {
  
  return _impl_.wobj_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Wobj::release_wobj_name() {
  // @@protoc_insertion_point(field_release:system_nrtstate.Wobj.wobj_name)
  return _impl_.wobj_name_.Release();
}
inline void Wobj::set_allocated_wobj_name(std::string* wobj_name) {
  if (wobj_name != nullptr) {
    
  } else {
    
  }
  _impl_.wobj_name_.SetAllocated(wobj_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.wobj_name_.IsDefault()) {
    _impl_.wobj_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:system_nrtstate.Wobj.wobj_name)
}

// repeated double data = 2;
inline int Wobj::_internal_data_size() const {
  return _impl_.data_.size();
}
inline int Wobj::data_size() const {
  return _internal_data_size();
}
inline void Wobj::clear_data() {
  _impl_.data_.Clear();
}
inline double Wobj::_internal_data(int index) const {
  return _impl_.data_.Get(index);
}
inline double Wobj::data(int index) const {
  // @@protoc_insertion_point(field_get:system_nrtstate.Wobj.data)
  return _internal_data(index);
}
inline void Wobj::set_data(int index, double value) {
  _impl_.data_.Set(index, value);
  // @@protoc_insertion_point(field_set:system_nrtstate.Wobj.data)
}
inline void Wobj::_internal_add_data(double value) {
  _impl_.data_.Add(value);
}
inline void Wobj::add_data(double value) {
  _internal_add_data(value);
  // @@protoc_insertion_point(field_add:system_nrtstate.Wobj.data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
Wobj::_internal_data() const {
  return _impl_.data_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
Wobj::data() const {
  // @@protoc_insertion_point(field_list:system_nrtstate.Wobj.data)
  return _internal_data();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
Wobj::_internal_mutable_data() {
  return &_impl_.data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
Wobj::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:system_nrtstate.Wobj.data)
  return _internal_mutable_data();
}

// -------------------------------------------------------------------

// Load

// string load_name = 1;
inline void Load::clear_load_name() {
  _impl_.load_name_.ClearToEmpty();
}
inline const std::string& Load::load_name() const {
  // @@protoc_insertion_point(field_get:system_nrtstate.Load.load_name)
  return _internal_load_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Load::set_load_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.load_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:system_nrtstate.Load.load_name)
}
inline std::string* Load::mutable_load_name() {
  std::string* _s = _internal_mutable_load_name();
  // @@protoc_insertion_point(field_mutable:system_nrtstate.Load.load_name)
  return _s;
}
inline const std::string& Load::_internal_load_name() const {
  return _impl_.load_name_.Get();
}
inline void Load::_internal_set_load_name(const std::string& value) {
  
  _impl_.load_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Load::_internal_mutable_load_name() {
  
  return _impl_.load_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Load::release_load_name() {
  // @@protoc_insertion_point(field_release:system_nrtstate.Load.load_name)
  return _impl_.load_name_.Release();
}
inline void Load::set_allocated_load_name(std::string* load_name) {
  if (load_name != nullptr) {
    
  } else {
    
  }
  _impl_.load_name_.SetAllocated(load_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.load_name_.IsDefault()) {
    _impl_.load_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:system_nrtstate.Load.load_name)
}

// repeated double data = 2;
inline int Load::_internal_data_size() const {
  return _impl_.data_.size();
}
inline int Load::data_size() const {
  return _internal_data_size();
}
inline void Load::clear_data() {
  _impl_.data_.Clear();
}
inline double Load::_internal_data(int index) const {
  return _impl_.data_.Get(index);
}
inline double Load::data(int index) const {
  // @@protoc_insertion_point(field_get:system_nrtstate.Load.data)
  return _internal_data(index);
}
inline void Load::set_data(int index, double value) {
  _impl_.data_.Set(index, value);
  // @@protoc_insertion_point(field_set:system_nrtstate.Load.data)
}
inline void Load::_internal_add_data(double value) {
  _impl_.data_.Add(value);
}
inline void Load::add_data(double value) {
  _internal_add_data(value);
  // @@protoc_insertion_point(field_add:system_nrtstate.Load.data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
Load::_internal_data() const {
  return _impl_.data_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
Load::data() const {
  // @@protoc_insertion_point(field_list:system_nrtstate.Load.data)
  return _internal_data();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
Load::_internal_mutable_data() {
  return &_impl_.data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
Load::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:system_nrtstate.Load.data)
  return _internal_mutable_data();
}

// -------------------------------------------------------------------

// Point

// string point_name = 1;
inline void Point::clear_point_name() {
  _impl_.point_name_.ClearToEmpty();
}
inline const std::string& Point::point_name() const {
  // @@protoc_insertion_point(field_get:system_nrtstate.Point.point_name)
  return _internal_point_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Point::set_point_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.point_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:system_nrtstate.Point.point_name)
}
inline std::string* Point::mutable_point_name() {
  std::string* _s = _internal_mutable_point_name();
  // @@protoc_insertion_point(field_mutable:system_nrtstate.Point.point_name)
  return _s;
}
inline const std::string& Point::_internal_point_name() const {
  return _impl_.point_name_.Get();
}
inline void Point::_internal_set_point_name(const std::string& value) {
  
  _impl_.point_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Point::_internal_mutable_point_name() {
  
  return _impl_.point_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Point::release_point_name() {
  // @@protoc_insertion_point(field_release:system_nrtstate.Point.point_name)
  return _impl_.point_name_.Release();
}
inline void Point::set_allocated_point_name(std::string* point_name) {
  if (point_name != nullptr) {
    
  } else {
    
  }
  _impl_.point_name_.SetAllocated(point_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.point_name_.IsDefault()) {
    _impl_.point_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:system_nrtstate.Point.point_name)
}

// .system_nrtstate.Tool tool = 2;
inline bool Point::_internal_has_tool() const {
  return this != internal_default_instance() && _impl_.tool_ != nullptr;
}
inline bool Point::has_tool() const {
  return _internal_has_tool();
}
inline void Point::clear_tool() {
  if (GetArenaForAllocation() == nullptr && _impl_.tool_ != nullptr) {
    delete _impl_.tool_;
  }
  _impl_.tool_ = nullptr;
}
inline const ::system_nrtstate::Tool& Point::_internal_tool() const {
  const ::system_nrtstate::Tool* p = _impl_.tool_;
  return p != nullptr ? *p : reinterpret_cast<const ::system_nrtstate::Tool&>(
      ::system_nrtstate::_Tool_default_instance_);
}
inline const ::system_nrtstate::Tool& Point::tool() const {
  // @@protoc_insertion_point(field_get:system_nrtstate.Point.tool)
  return _internal_tool();
}
inline void Point::unsafe_arena_set_allocated_tool(
    ::system_nrtstate::Tool* tool) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tool_);
  }
  _impl_.tool_ = tool;
  if (tool) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:system_nrtstate.Point.tool)
}
inline ::system_nrtstate::Tool* Point::release_tool() {
  
  ::system_nrtstate::Tool* temp = _impl_.tool_;
  _impl_.tool_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::system_nrtstate::Tool* Point::unsafe_arena_release_tool() {
  // @@protoc_insertion_point(field_release:system_nrtstate.Point.tool)
  
  ::system_nrtstate::Tool* temp = _impl_.tool_;
  _impl_.tool_ = nullptr;
  return temp;
}
inline ::system_nrtstate::Tool* Point::_internal_mutable_tool() {
  
  if (_impl_.tool_ == nullptr) {
    auto* p = CreateMaybeMessage<::system_nrtstate::Tool>(GetArenaForAllocation());
    _impl_.tool_ = p;
  }
  return _impl_.tool_;
}
inline ::system_nrtstate::Tool* Point::mutable_tool() {
  ::system_nrtstate::Tool* _msg = _internal_mutable_tool();
  // @@protoc_insertion_point(field_mutable:system_nrtstate.Point.tool)
  return _msg;
}
inline void Point::set_allocated_tool(::system_nrtstate::Tool* tool) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tool_;
  }
  if (tool) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tool);
    if (message_arena != submessage_arena) {
      tool = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tool, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.tool_ = tool;
  // @@protoc_insertion_point(field_set_allocated:system_nrtstate.Point.tool)
}

// .system_nrtstate.Wobj wobj = 3;
inline bool Point::_internal_has_wobj() const {
  return this != internal_default_instance() && _impl_.wobj_ != nullptr;
}
inline bool Point::has_wobj() const {
  return _internal_has_wobj();
}
inline void Point::clear_wobj() {
  if (GetArenaForAllocation() == nullptr && _impl_.wobj_ != nullptr) {
    delete _impl_.wobj_;
  }
  _impl_.wobj_ = nullptr;
}
inline const ::system_nrtstate::Wobj& Point::_internal_wobj() const {
  const ::system_nrtstate::Wobj* p = _impl_.wobj_;
  return p != nullptr ? *p : reinterpret_cast<const ::system_nrtstate::Wobj&>(
      ::system_nrtstate::_Wobj_default_instance_);
}
inline const ::system_nrtstate::Wobj& Point::wobj() const {
  // @@protoc_insertion_point(field_get:system_nrtstate.Point.wobj)
  return _internal_wobj();
}
inline void Point::unsafe_arena_set_allocated_wobj(
    ::system_nrtstate::Wobj* wobj) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.wobj_);
  }
  _impl_.wobj_ = wobj;
  if (wobj) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:system_nrtstate.Point.wobj)
}
inline ::system_nrtstate::Wobj* Point::release_wobj() {
  
  ::system_nrtstate::Wobj* temp = _impl_.wobj_;
  _impl_.wobj_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::system_nrtstate::Wobj* Point::unsafe_arena_release_wobj() {
  // @@protoc_insertion_point(field_release:system_nrtstate.Point.wobj)
  
  ::system_nrtstate::Wobj* temp = _impl_.wobj_;
  _impl_.wobj_ = nullptr;
  return temp;
}
inline ::system_nrtstate::Wobj* Point::_internal_mutable_wobj() {
  
  if (_impl_.wobj_ == nullptr) {
    auto* p = CreateMaybeMessage<::system_nrtstate::Wobj>(GetArenaForAllocation());
    _impl_.wobj_ = p;
  }
  return _impl_.wobj_;
}
inline ::system_nrtstate::Wobj* Point::mutable_wobj() {
  ::system_nrtstate::Wobj* _msg = _internal_mutable_wobj();
  // @@protoc_insertion_point(field_mutable:system_nrtstate.Point.wobj)
  return _msg;
}
inline void Point::set_allocated_wobj(::system_nrtstate::Wobj* wobj) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.wobj_;
  }
  if (wobj) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(wobj);
    if (message_arena != submessage_arena) {
      wobj = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wobj, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.wobj_ = wobj;
  // @@protoc_insertion_point(field_set_allocated:system_nrtstate.Point.wobj)
}

// repeated double robottarget = 4;
inline int Point::_internal_robottarget_size() const {
  return _impl_.robottarget_.size();
}
inline int Point::robottarget_size() const {
  return _internal_robottarget_size();
}
inline void Point::clear_robottarget() {
  _impl_.robottarget_.Clear();
}
inline double Point::_internal_robottarget(int index) const {
  return _impl_.robottarget_.Get(index);
}
inline double Point::robottarget(int index) const {
  // @@protoc_insertion_point(field_get:system_nrtstate.Point.robottarget)
  return _internal_robottarget(index);
}
inline void Point::set_robottarget(int index, double value) {
  _impl_.robottarget_.Set(index, value);
  // @@protoc_insertion_point(field_set:system_nrtstate.Point.robottarget)
}
inline void Point::_internal_add_robottarget(double value) {
  _impl_.robottarget_.Add(value);
}
inline void Point::add_robottarget(double value) {
  _internal_add_robottarget(value);
  // @@protoc_insertion_point(field_add:system_nrtstate.Point.robottarget)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
Point::_internal_robottarget() const {
  return _impl_.robottarget_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
Point::robottarget() const {
  // @@protoc_insertion_point(field_list:system_nrtstate.Point.robottarget)
  return _internal_robottarget();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
Point::_internal_mutable_robottarget() {
  return &_impl_.robottarget_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
Point::mutable_robottarget() {
  // @@protoc_insertion_point(field_mutable_list:system_nrtstate.Point.robottarget)
  return _internal_mutable_robottarget();
}

// repeated double jointtarget = 5;
inline int Point::_internal_jointtarget_size() const {
  return _impl_.jointtarget_.size();
}
inline int Point::jointtarget_size() const {
  return _internal_jointtarget_size();
}
inline void Point::clear_jointtarget() {
  _impl_.jointtarget_.Clear();
}
inline double Point::_internal_jointtarget(int index) const {
  return _impl_.jointtarget_.Get(index);
}
inline double Point::jointtarget(int index) const {
  // @@protoc_insertion_point(field_get:system_nrtstate.Point.jointtarget)
  return _internal_jointtarget(index);
}
inline void Point::set_jointtarget(int index, double value) {
  _impl_.jointtarget_.Set(index, value);
  // @@protoc_insertion_point(field_set:system_nrtstate.Point.jointtarget)
}
inline void Point::_internal_add_jointtarget(double value) {
  _impl_.jointtarget_.Add(value);
}
inline void Point::add_jointtarget(double value) {
  _internal_add_jointtarget(value);
  // @@protoc_insertion_point(field_add:system_nrtstate.Point.jointtarget)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
Point::_internal_jointtarget() const {
  return _impl_.jointtarget_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
Point::jointtarget() const {
  // @@protoc_insertion_point(field_list:system_nrtstate.Point.jointtarget)
  return _internal_jointtarget();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
Point::_internal_mutable_jointtarget() {
  return &_impl_.jointtarget_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
Point::mutable_jointtarget() {
  // @@protoc_insertion_point(field_mutable_list:system_nrtstate.Point.jointtarget)
  return _internal_mutable_jointtarget();
}

// -------------------------------------------------------------------

// Model

// string model_name = 1;
inline void Model::clear_model_name() {
  _impl_.model_name_.ClearToEmpty();
}
inline const std::string& Model::model_name() const {
  // @@protoc_insertion_point(field_get:system_nrtstate.Model.model_name)
  return _internal_model_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Model::set_model_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:system_nrtstate.Model.model_name)
}
inline std::string* Model::mutable_model_name() {
  std::string* _s = _internal_mutable_model_name();
  // @@protoc_insertion_point(field_mutable:system_nrtstate.Model.model_name)
  return _s;
}
inline const std::string& Model::_internal_model_name() const {
  return _impl_.model_name_.Get();
}
inline void Model::_internal_set_model_name(const std::string& value) {
  
  _impl_.model_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Model::_internal_mutable_model_name() {
  
  return _impl_.model_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Model::release_model_name() {
  // @@protoc_insertion_point(field_release:system_nrtstate.Model.model_name)
  return _impl_.model_name_.Release();
}
inline void Model::set_allocated_model_name(std::string* model_name) {
  if (model_name != nullptr) {
    
  } else {
    
  }
  _impl_.model_name_.SetAllocated(model_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_name_.IsDefault()) {
    _impl_.model_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:system_nrtstate.Model.model_name)
}

// string model_type = 2;
inline void Model::clear_model_type() {
  _impl_.model_type_.ClearToEmpty();
}
inline const std::string& Model::model_type() const {
  // @@protoc_insertion_point(field_get:system_nrtstate.Model.model_type)
  return _internal_model_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Model::set_model_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:system_nrtstate.Model.model_type)
}
inline std::string* Model::mutable_model_type() {
  std::string* _s = _internal_mutable_model_type();
  // @@protoc_insertion_point(field_mutable:system_nrtstate.Model.model_type)
  return _s;
}
inline const std::string& Model::_internal_model_type() const {
  return _impl_.model_type_.Get();
}
inline void Model::_internal_set_model_type(const std::string& value) {
  
  _impl_.model_type_.Set(value, GetArenaForAllocation());
}
inline std::string* Model::_internal_mutable_model_type() {
  
  return _impl_.model_type_.Mutable(GetArenaForAllocation());
}
inline std::string* Model::release_model_type() {
  // @@protoc_insertion_point(field_release:system_nrtstate.Model.model_type)
  return _impl_.model_type_.Release();
}
inline void Model::set_allocated_model_type(std::string* model_type) {
  if (model_type != nullptr) {
    
  } else {
    
  }
  _impl_.model_type_.SetAllocated(model_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_type_.IsDefault()) {
    _impl_.model_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:system_nrtstate.Model.model_type)
}

// repeated .system_nrtstate.Joint joint = 3;
inline int Model::_internal_joint_size() const {
  return _impl_.joint_.size();
}
inline int Model::joint_size() const {
  return _internal_joint_size();
}
inline void Model::clear_joint() {
  _impl_.joint_.Clear();
}
inline ::system_nrtstate::Joint* Model::mutable_joint(int index) {
  // @@protoc_insertion_point(field_mutable:system_nrtstate.Model.joint)
  return _impl_.joint_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_nrtstate::Joint >*
Model::mutable_joint() {
  // @@protoc_insertion_point(field_mutable_list:system_nrtstate.Model.joint)
  return &_impl_.joint_;
}
inline const ::system_nrtstate::Joint& Model::_internal_joint(int index) const {
  return _impl_.joint_.Get(index);
}
inline const ::system_nrtstate::Joint& Model::joint(int index) const {
  // @@protoc_insertion_point(field_get:system_nrtstate.Model.joint)
  return _internal_joint(index);
}
inline ::system_nrtstate::Joint* Model::_internal_add_joint() {
  return _impl_.joint_.Add();
}
inline ::system_nrtstate::Joint* Model::add_joint() {
  ::system_nrtstate::Joint* _add = _internal_add_joint();
  // @@protoc_insertion_point(field_add:system_nrtstate.Model.joint)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_nrtstate::Joint >&
Model::joint() const {
  // @@protoc_insertion_point(field_list:system_nrtstate.Model.joint)
  return _impl_.joint_;
}

// repeated .system_nrtstate.Tool tools = 5;
inline int Model::_internal_tools_size() const {
  return _impl_.tools_.size();
}
inline int Model::tools_size() const {
  return _internal_tools_size();
}
inline void Model::clear_tools() {
  _impl_.tools_.Clear();
}
inline ::system_nrtstate::Tool* Model::mutable_tools(int index) {
  // @@protoc_insertion_point(field_mutable:system_nrtstate.Model.tools)
  return _impl_.tools_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_nrtstate::Tool >*
Model::mutable_tools() {
  // @@protoc_insertion_point(field_mutable_list:system_nrtstate.Model.tools)
  return &_impl_.tools_;
}
inline const ::system_nrtstate::Tool& Model::_internal_tools(int index) const {
  return _impl_.tools_.Get(index);
}
inline const ::system_nrtstate::Tool& Model::tools(int index) const {
  // @@protoc_insertion_point(field_get:system_nrtstate.Model.tools)
  return _internal_tools(index);
}
inline ::system_nrtstate::Tool* Model::_internal_add_tools() {
  return _impl_.tools_.Add();
}
inline ::system_nrtstate::Tool* Model::add_tools() {
  ::system_nrtstate::Tool* _add = _internal_add_tools();
  // @@protoc_insertion_point(field_add:system_nrtstate.Model.tools)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_nrtstate::Tool >&
Model::tools() const {
  // @@protoc_insertion_point(field_list:system_nrtstate.Model.tools)
  return _impl_.tools_;
}

// repeated .system_nrtstate.Wobj wobjs = 6;
inline int Model::_internal_wobjs_size() const {
  return _impl_.wobjs_.size();
}
inline int Model::wobjs_size() const {
  return _internal_wobjs_size();
}
inline void Model::clear_wobjs() {
  _impl_.wobjs_.Clear();
}
inline ::system_nrtstate::Wobj* Model::mutable_wobjs(int index) {
  // @@protoc_insertion_point(field_mutable:system_nrtstate.Model.wobjs)
  return _impl_.wobjs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_nrtstate::Wobj >*
Model::mutable_wobjs() {
  // @@protoc_insertion_point(field_mutable_list:system_nrtstate.Model.wobjs)
  return &_impl_.wobjs_;
}
inline const ::system_nrtstate::Wobj& Model::_internal_wobjs(int index) const {
  return _impl_.wobjs_.Get(index);
}
inline const ::system_nrtstate::Wobj& Model::wobjs(int index) const {
  // @@protoc_insertion_point(field_get:system_nrtstate.Model.wobjs)
  return _internal_wobjs(index);
}
inline ::system_nrtstate::Wobj* Model::_internal_add_wobjs() {
  return _impl_.wobjs_.Add();
}
inline ::system_nrtstate::Wobj* Model::add_wobjs() {
  ::system_nrtstate::Wobj* _add = _internal_add_wobjs();
  // @@protoc_insertion_point(field_add:system_nrtstate.Model.wobjs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_nrtstate::Wobj >&
Model::wobjs() const {
  // @@protoc_insertion_point(field_list:system_nrtstate.Model.wobjs)
  return _impl_.wobjs_;
}

// repeated .system_nrtstate.Load loads = 7;
inline int Model::_internal_loads_size() const {
  return _impl_.loads_.size();
}
inline int Model::loads_size() const {
  return _internal_loads_size();
}
inline void Model::clear_loads() {
  _impl_.loads_.Clear();
}
inline ::system_nrtstate::Load* Model::mutable_loads(int index) {
  // @@protoc_insertion_point(field_mutable:system_nrtstate.Model.loads)
  return _impl_.loads_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_nrtstate::Load >*
Model::mutable_loads() {
  // @@protoc_insertion_point(field_mutable_list:system_nrtstate.Model.loads)
  return &_impl_.loads_;
}
inline const ::system_nrtstate::Load& Model::_internal_loads(int index) const {
  return _impl_.loads_.Get(index);
}
inline const ::system_nrtstate::Load& Model::loads(int index) const {
  // @@protoc_insertion_point(field_get:system_nrtstate.Model.loads)
  return _internal_loads(index);
}
inline ::system_nrtstate::Load* Model::_internal_add_loads() {
  return _impl_.loads_.Add();
}
inline ::system_nrtstate::Load* Model::add_loads() {
  ::system_nrtstate::Load* _add = _internal_add_loads();
  // @@protoc_insertion_point(field_add:system_nrtstate.Model.loads)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_nrtstate::Load >&
Model::loads() const {
  // @@protoc_insertion_point(field_list:system_nrtstate.Model.loads)
  return _impl_.loads_;
}

// repeated .system_nrtstate.Point teach_points = 8;
inline int Model::_internal_teach_points_size() const {
  return _impl_.teach_points_.size();
}
inline int Model::teach_points_size() const {
  return _internal_teach_points_size();
}
inline void Model::clear_teach_points() {
  _impl_.teach_points_.Clear();
}
inline ::system_nrtstate::Point* Model::mutable_teach_points(int index) {
  // @@protoc_insertion_point(field_mutable:system_nrtstate.Model.teach_points)
  return _impl_.teach_points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_nrtstate::Point >*
Model::mutable_teach_points() {
  // @@protoc_insertion_point(field_mutable_list:system_nrtstate.Model.teach_points)
  return &_impl_.teach_points_;
}
inline const ::system_nrtstate::Point& Model::_internal_teach_points(int index) const {
  return _impl_.teach_points_.Get(index);
}
inline const ::system_nrtstate::Point& Model::teach_points(int index) const {
  // @@protoc_insertion_point(field_get:system_nrtstate.Model.teach_points)
  return _internal_teach_points(index);
}
inline ::system_nrtstate::Point* Model::_internal_add_teach_points() {
  return _impl_.teach_points_.Add();
}
inline ::system_nrtstate::Point* Model::add_teach_points() {
  ::system_nrtstate::Point* _add = _internal_add_teach_points();
  // @@protoc_insertion_point(field_add:system_nrtstate.Model.teach_points)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_nrtstate::Point >&
Model::teach_points() const {
  // @@protoc_insertion_point(field_list:system_nrtstate.Model.teach_points)
  return _impl_.teach_points_;
}

// -------------------------------------------------------------------

// Subsystem

// string subsystem_name = 1;
inline void Subsystem::clear_subsystem_name() {
  _impl_.subsystem_name_.ClearToEmpty();
}
inline const std::string& Subsystem::subsystem_name() const {
  // @@protoc_insertion_point(field_get:system_nrtstate.Subsystem.subsystem_name)
  return _internal_subsystem_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Subsystem::set_subsystem_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.subsystem_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:system_nrtstate.Subsystem.subsystem_name)
}
inline std::string* Subsystem::mutable_subsystem_name() {
  std::string* _s = _internal_mutable_subsystem_name();
  // @@protoc_insertion_point(field_mutable:system_nrtstate.Subsystem.subsystem_name)
  return _s;
}
inline const std::string& Subsystem::_internal_subsystem_name() const {
  return _impl_.subsystem_name_.Get();
}
inline void Subsystem::_internal_set_subsystem_name(const std::string& value) {
  
  _impl_.subsystem_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Subsystem::_internal_mutable_subsystem_name() {
  
  return _impl_.subsystem_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Subsystem::release_subsystem_name() {
  // @@protoc_insertion_point(field_release:system_nrtstate.Subsystem.subsystem_name)
  return _impl_.subsystem_name_.Release();
}
inline void Subsystem::set_allocated_subsystem_name(std::string* subsystem_name) {
  if (subsystem_name != nullptr) {
    
  } else {
    
  }
  _impl_.subsystem_name_.SetAllocated(subsystem_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.subsystem_name_.IsDefault()) {
    _impl_.subsystem_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:system_nrtstate.Subsystem.subsystem_name)
}

// int32 id = 2;
inline void Subsystem::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t Subsystem::_internal_id() const {
  return _impl_.id_;
}
inline int32_t Subsystem::id() const {
  // @@protoc_insertion_point(field_get:system_nrtstate.Subsystem.id)
  return _internal_id();
}
inline void Subsystem::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void Subsystem::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:system_nrtstate.Subsystem.id)
}

// int32 state = 3;
inline void Subsystem::clear_state() {
  _impl_.state_ = 0;
}
inline int32_t Subsystem::_internal_state() const {
  return _impl_.state_;
}
inline int32_t Subsystem::state() const {
  // @@protoc_insertion_point(field_get:system_nrtstate.Subsystem.state)
  return _internal_state();
}
inline void Subsystem::_internal_set_state(int32_t value) {
  
  _impl_.state_ = value;
}
inline void Subsystem::set_state(int32_t value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:system_nrtstate.Subsystem.state)
}

// -------------------------------------------------------------------

// Sensor

// string sensor_name = 1;
inline void Sensor::clear_sensor_name() {
  _impl_.sensor_name_.ClearToEmpty();
}
inline const std::string& Sensor::sensor_name() const {
  // @@protoc_insertion_point(field_get:system_nrtstate.Sensor.sensor_name)
  return _internal_sensor_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Sensor::set_sensor_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sensor_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:system_nrtstate.Sensor.sensor_name)
}
inline std::string* Sensor::mutable_sensor_name() {
  std::string* _s = _internal_mutable_sensor_name();
  // @@protoc_insertion_point(field_mutable:system_nrtstate.Sensor.sensor_name)
  return _s;
}
inline const std::string& Sensor::_internal_sensor_name() const {
  return _impl_.sensor_name_.Get();
}
inline void Sensor::_internal_set_sensor_name(const std::string& value) {
  
  _impl_.sensor_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Sensor::_internal_mutable_sensor_name() {
  
  return _impl_.sensor_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Sensor::release_sensor_name() {
  // @@protoc_insertion_point(field_release:system_nrtstate.Sensor.sensor_name)
  return _impl_.sensor_name_.Release();
}
inline void Sensor::set_allocated_sensor_name(std::string* sensor_name) {
  if (sensor_name != nullptr) {
    
  } else {
    
  }
  _impl_.sensor_name_.SetAllocated(sensor_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sensor_name_.IsDefault()) {
    _impl_.sensor_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:system_nrtstate.Sensor.sensor_name)
}

// int32 id = 2;
inline void Sensor::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t Sensor::_internal_id() const {
  return _impl_.id_;
}
inline int32_t Sensor::id() const {
  // @@protoc_insertion_point(field_get:system_nrtstate.Sensor.id)
  return _internal_id();
}
inline void Sensor::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void Sensor::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:system_nrtstate.Sensor.id)
}

// int32 state = 3;
inline void Sensor::clear_state() {
  _impl_.state_ = 0;
}
inline int32_t Sensor::_internal_state() const {
  return _impl_.state_;
}
inline int32_t Sensor::state() const {
  // @@protoc_insertion_point(field_get:system_nrtstate.Sensor.state)
  return _internal_state();
}
inline void Sensor::_internal_set_state(int32_t value) {
  
  _impl_.state_ = value;
}
inline void Sensor::set_state(int32_t value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:system_nrtstate.Sensor.state)
}

// -------------------------------------------------------------------

// Interface

// string interface_name = 1;
inline void Interface::clear_interface_name() {
  _impl_.interface_name_.ClearToEmpty();
}
inline const std::string& Interface::interface_name() const {
  // @@protoc_insertion_point(field_get:system_nrtstate.Interface.interface_name)
  return _internal_interface_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Interface::set_interface_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.interface_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:system_nrtstate.Interface.interface_name)
}
inline std::string* Interface::mutable_interface_name() {
  std::string* _s = _internal_mutable_interface_name();
  // @@protoc_insertion_point(field_mutable:system_nrtstate.Interface.interface_name)
  return _s;
}
inline const std::string& Interface::_internal_interface_name() const {
  return _impl_.interface_name_.Get();
}
inline void Interface::_internal_set_interface_name(const std::string& value) {
  
  _impl_.interface_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Interface::_internal_mutable_interface_name() {
  
  return _impl_.interface_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Interface::release_interface_name() {
  // @@protoc_insertion_point(field_release:system_nrtstate.Interface.interface_name)
  return _impl_.interface_name_.Release();
}
inline void Interface::set_allocated_interface_name(std::string* interface_name) {
  if (interface_name != nullptr) {
    
  } else {
    
  }
  _impl_.interface_name_.SetAllocated(interface_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.interface_name_.IsDefault()) {
    _impl_.interface_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:system_nrtstate.Interface.interface_name)
}

// int32 id = 2;
inline void Interface::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t Interface::_internal_id() const {
  return _impl_.id_;
}
inline int32_t Interface::id() const {
  // @@protoc_insertion_point(field_get:system_nrtstate.Interface.id)
  return _internal_id();
}
inline void Interface::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void Interface::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:system_nrtstate.Interface.id)
}

// int32 state = 3;
inline void Interface::clear_state() {
  _impl_.state_ = 0;
}
inline int32_t Interface::_internal_state() const {
  return _impl_.state_;
}
inline int32_t Interface::state() const {
  // @@protoc_insertion_point(field_get:system_nrtstate.Interface.state)
  return _internal_state();
}
inline void Interface::_internal_set_state(int32_t value) {
  
  _impl_.state_ = value;
}
inline void Interface::set_state(int32_t value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:system_nrtstate.Interface.state)
}

// -------------------------------------------------------------------

// SystemNrtState

// .system_nrtstate.Header head = 1;
inline bool SystemNrtState::_internal_has_head() const {
  return this != internal_default_instance() && _impl_.head_ != nullptr;
}
inline bool SystemNrtState::has_head() const {
  return _internal_has_head();
}
inline void SystemNrtState::clear_head() {
  if (GetArenaForAllocation() == nullptr && _impl_.head_ != nullptr) {
    delete _impl_.head_;
  }
  _impl_.head_ = nullptr;
}
inline const ::system_nrtstate::Header& SystemNrtState::_internal_head() const {
  const ::system_nrtstate::Header* p = _impl_.head_;
  return p != nullptr ? *p : reinterpret_cast<const ::system_nrtstate::Header&>(
      ::system_nrtstate::_Header_default_instance_);
}
inline const ::system_nrtstate::Header& SystemNrtState::head() const {
  // @@protoc_insertion_point(field_get:system_nrtstate.SystemNrtState.head)
  return _internal_head();
}
inline void SystemNrtState::unsafe_arena_set_allocated_head(
    ::system_nrtstate::Header* head) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.head_);
  }
  _impl_.head_ = head;
  if (head) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:system_nrtstate.SystemNrtState.head)
}
inline ::system_nrtstate::Header* SystemNrtState::release_head() {
  
  ::system_nrtstate::Header* temp = _impl_.head_;
  _impl_.head_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::system_nrtstate::Header* SystemNrtState::unsafe_arena_release_head() {
  // @@protoc_insertion_point(field_release:system_nrtstate.SystemNrtState.head)
  
  ::system_nrtstate::Header* temp = _impl_.head_;
  _impl_.head_ = nullptr;
  return temp;
}
inline ::system_nrtstate::Header* SystemNrtState::_internal_mutable_head() {
  
  if (_impl_.head_ == nullptr) {
    auto* p = CreateMaybeMessage<::system_nrtstate::Header>(GetArenaForAllocation());
    _impl_.head_ = p;
  }
  return _impl_.head_;
}
inline ::system_nrtstate::Header* SystemNrtState::mutable_head() {
  ::system_nrtstate::Header* _msg = _internal_mutable_head();
  // @@protoc_insertion_point(field_mutable:system_nrtstate.SystemNrtState.head)
  return _msg;
}
inline void SystemNrtState::set_allocated_head(::system_nrtstate::Header* head) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.head_;
  }
  if (head) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(head);
    if (message_arena != submessage_arena) {
      head = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, head, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.head_ = head;
  // @@protoc_insertion_point(field_set_allocated:system_nrtstate.SystemNrtState.head)
}

// bool system_running_state = 2;
inline void SystemNrtState::clear_system_running_state() {
  _impl_.system_running_state_ = false;
}
inline bool SystemNrtState::_internal_system_running_state() const {
  return _impl_.system_running_state_;
}
inline bool SystemNrtState::system_running_state() const {
  // @@protoc_insertion_point(field_get:system_nrtstate.SystemNrtState.system_running_state)
  return _internal_system_running_state();
}
inline void SystemNrtState::_internal_set_system_running_state(bool value) {
  
  _impl_.system_running_state_ = value;
}
inline void SystemNrtState::set_system_running_state(bool value) {
  _internal_set_system_running_state(value);
  // @@protoc_insertion_point(field_set:system_nrtstate.SystemNrtState.system_running_state)
}

// repeated .system_nrtstate.Model model = 3;
inline int SystemNrtState::_internal_model_size() const {
  return _impl_.model_.size();
}
inline int SystemNrtState::model_size() const {
  return _internal_model_size();
}
inline void SystemNrtState::clear_model() {
  _impl_.model_.Clear();
}
inline ::system_nrtstate::Model* SystemNrtState::mutable_model(int index) {
  // @@protoc_insertion_point(field_mutable:system_nrtstate.SystemNrtState.model)
  return _impl_.model_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_nrtstate::Model >*
SystemNrtState::mutable_model() {
  // @@protoc_insertion_point(field_mutable_list:system_nrtstate.SystemNrtState.model)
  return &_impl_.model_;
}
inline const ::system_nrtstate::Model& SystemNrtState::_internal_model(int index) const {
  return _impl_.model_.Get(index);
}
inline const ::system_nrtstate::Model& SystemNrtState::model(int index) const {
  // @@protoc_insertion_point(field_get:system_nrtstate.SystemNrtState.model)
  return _internal_model(index);
}
inline ::system_nrtstate::Model* SystemNrtState::_internal_add_model() {
  return _impl_.model_.Add();
}
inline ::system_nrtstate::Model* SystemNrtState::add_model() {
  ::system_nrtstate::Model* _add = _internal_add_model();
  // @@protoc_insertion_point(field_add:system_nrtstate.SystemNrtState.model)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_nrtstate::Model >&
SystemNrtState::model() const {
  // @@protoc_insertion_point(field_list:system_nrtstate.SystemNrtState.model)
  return _impl_.model_;
}

// .system_nrtstate.Controller controller = 4;
inline bool SystemNrtState::_internal_has_controller() const {
  return this != internal_default_instance() && _impl_.controller_ != nullptr;
}
inline bool SystemNrtState::has_controller() const {
  return _internal_has_controller();
}
inline void SystemNrtState::clear_controller() {
  if (GetArenaForAllocation() == nullptr && _impl_.controller_ != nullptr) {
    delete _impl_.controller_;
  }
  _impl_.controller_ = nullptr;
}
inline const ::system_nrtstate::Controller& SystemNrtState::_internal_controller() const {
  const ::system_nrtstate::Controller* p = _impl_.controller_;
  return p != nullptr ? *p : reinterpret_cast<const ::system_nrtstate::Controller&>(
      ::system_nrtstate::_Controller_default_instance_);
}
inline const ::system_nrtstate::Controller& SystemNrtState::controller() const {
  // @@protoc_insertion_point(field_get:system_nrtstate.SystemNrtState.controller)
  return _internal_controller();
}
inline void SystemNrtState::unsafe_arena_set_allocated_controller(
    ::system_nrtstate::Controller* controller) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controller_);
  }
  _impl_.controller_ = controller;
  if (controller) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:system_nrtstate.SystemNrtState.controller)
}
inline ::system_nrtstate::Controller* SystemNrtState::release_controller() {
  
  ::system_nrtstate::Controller* temp = _impl_.controller_;
  _impl_.controller_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::system_nrtstate::Controller* SystemNrtState::unsafe_arena_release_controller() {
  // @@protoc_insertion_point(field_release:system_nrtstate.SystemNrtState.controller)
  
  ::system_nrtstate::Controller* temp = _impl_.controller_;
  _impl_.controller_ = nullptr;
  return temp;
}
inline ::system_nrtstate::Controller* SystemNrtState::_internal_mutable_controller() {
  
  if (_impl_.controller_ == nullptr) {
    auto* p = CreateMaybeMessage<::system_nrtstate::Controller>(GetArenaForAllocation());
    _impl_.controller_ = p;
  }
  return _impl_.controller_;
}
inline ::system_nrtstate::Controller* SystemNrtState::mutable_controller() {
  ::system_nrtstate::Controller* _msg = _internal_mutable_controller();
  // @@protoc_insertion_point(field_mutable:system_nrtstate.SystemNrtState.controller)
  return _msg;
}
inline void SystemNrtState::set_allocated_controller(::system_nrtstate::Controller* controller) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.controller_;
  }
  if (controller) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(controller);
    if (message_arena != submessage_arena) {
      controller = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, controller, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.controller_ = controller;
  // @@protoc_insertion_point(field_set_allocated:system_nrtstate.SystemNrtState.controller)
}

// repeated .system_nrtstate.Subsystem subsystem = 5;
inline int SystemNrtState::_internal_subsystem_size() const {
  return _impl_.subsystem_.size();
}
inline int SystemNrtState::subsystem_size() const {
  return _internal_subsystem_size();
}
inline void SystemNrtState::clear_subsystem() {
  _impl_.subsystem_.Clear();
}
inline ::system_nrtstate::Subsystem* SystemNrtState::mutable_subsystem(int index) {
  // @@protoc_insertion_point(field_mutable:system_nrtstate.SystemNrtState.subsystem)
  return _impl_.subsystem_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_nrtstate::Subsystem >*
SystemNrtState::mutable_subsystem() {
  // @@protoc_insertion_point(field_mutable_list:system_nrtstate.SystemNrtState.subsystem)
  return &_impl_.subsystem_;
}
inline const ::system_nrtstate::Subsystem& SystemNrtState::_internal_subsystem(int index) const {
  return _impl_.subsystem_.Get(index);
}
inline const ::system_nrtstate::Subsystem& SystemNrtState::subsystem(int index) const {
  // @@protoc_insertion_point(field_get:system_nrtstate.SystemNrtState.subsystem)
  return _internal_subsystem(index);
}
inline ::system_nrtstate::Subsystem* SystemNrtState::_internal_add_subsystem() {
  return _impl_.subsystem_.Add();
}
inline ::system_nrtstate::Subsystem* SystemNrtState::add_subsystem() {
  ::system_nrtstate::Subsystem* _add = _internal_add_subsystem();
  // @@protoc_insertion_point(field_add:system_nrtstate.SystemNrtState.subsystem)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_nrtstate::Subsystem >&
SystemNrtState::subsystem() const {
  // @@protoc_insertion_point(field_list:system_nrtstate.SystemNrtState.subsystem)
  return _impl_.subsystem_;
}

// repeated .system_nrtstate.Sensor sensor = 6;
inline int SystemNrtState::_internal_sensor_size() const {
  return _impl_.sensor_.size();
}
inline int SystemNrtState::sensor_size() const {
  return _internal_sensor_size();
}
inline void SystemNrtState::clear_sensor() {
  _impl_.sensor_.Clear();
}
inline ::system_nrtstate::Sensor* SystemNrtState::mutable_sensor(int index) {
  // @@protoc_insertion_point(field_mutable:system_nrtstate.SystemNrtState.sensor)
  return _impl_.sensor_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_nrtstate::Sensor >*
SystemNrtState::mutable_sensor() {
  // @@protoc_insertion_point(field_mutable_list:system_nrtstate.SystemNrtState.sensor)
  return &_impl_.sensor_;
}
inline const ::system_nrtstate::Sensor& SystemNrtState::_internal_sensor(int index) const {
  return _impl_.sensor_.Get(index);
}
inline const ::system_nrtstate::Sensor& SystemNrtState::sensor(int index) const {
  // @@protoc_insertion_point(field_get:system_nrtstate.SystemNrtState.sensor)
  return _internal_sensor(index);
}
inline ::system_nrtstate::Sensor* SystemNrtState::_internal_add_sensor() {
  return _impl_.sensor_.Add();
}
inline ::system_nrtstate::Sensor* SystemNrtState::add_sensor() {
  ::system_nrtstate::Sensor* _add = _internal_add_sensor();
  // @@protoc_insertion_point(field_add:system_nrtstate.SystemNrtState.sensor)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_nrtstate::Sensor >&
SystemNrtState::sensor() const {
  // @@protoc_insertion_point(field_list:system_nrtstate.SystemNrtState.sensor)
  return _impl_.sensor_;
}

// repeated .system_nrtstate.Interface interface = 7;
inline int SystemNrtState::_internal_interface_size() const {
  return _impl_.interface_.size();
}
inline int SystemNrtState::interface_size() const {
  return _internal_interface_size();
}
inline void SystemNrtState::clear_interface() {
  _impl_.interface_.Clear();
}
inline ::system_nrtstate::Interface* SystemNrtState::mutable_interface(int index) {
  // @@protoc_insertion_point(field_mutable:system_nrtstate.SystemNrtState.interface)
  return _impl_.interface_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_nrtstate::Interface >*
SystemNrtState::mutable_interface() {
  // @@protoc_insertion_point(field_mutable_list:system_nrtstate.SystemNrtState.interface)
  return &_impl_.interface_;
}
inline const ::system_nrtstate::Interface& SystemNrtState::_internal_interface(int index) const {
  return _impl_.interface_.Get(index);
}
inline const ::system_nrtstate::Interface& SystemNrtState::interface(int index) const {
  // @@protoc_insertion_point(field_get:system_nrtstate.SystemNrtState.interface)
  return _internal_interface(index);
}
inline ::system_nrtstate::Interface* SystemNrtState::_internal_add_interface() {
  return _impl_.interface_.Add();
}
inline ::system_nrtstate::Interface* SystemNrtState::add_interface() {
  ::system_nrtstate::Interface* _add = _internal_add_interface();
  // @@protoc_insertion_point(field_add:system_nrtstate.SystemNrtState.interface)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_nrtstate::Interface >&
SystemNrtState::interface() const {
  // @@protoc_insertion_point(field_list:system_nrtstate.SystemNrtState.interface)
  return _impl_.interface_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace system_nrtstate

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_overall_5fsystem_5fnrtstate_2eproto

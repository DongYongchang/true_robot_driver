// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: overall_system_rtstate.proto
#define PROTOBUF_USE_DLLS
#ifndef GOOGLE_PROTOBUF_INCLUDED_overall_5fsystem_5frtstate_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_overall_5fsystem_5frtstate_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_overall_5fsystem_5frtstate_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_overall_5fsystem_5frtstate_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_overall_5fsystem_5frtstate_2eproto;
namespace system_rtstate {
class Controller;
struct ControllerDefaultTypeInternal;
extern ControllerDefaultTypeInternal _Controller_default_instance_;
class Ftvalue;
struct FtvalueDefaultTypeInternal;
extern FtvalueDefaultTypeInternal _Ftvalue_default_instance_;
class Header;
struct HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class Joint;
struct JointDefaultTypeInternal;
extern JointDefaultTypeInternal _Joint_default_instance_;
class Load;
struct LoadDefaultTypeInternal;
extern LoadDefaultTypeInternal _Load_default_instance_;
class Model;
struct ModelDefaultTypeInternal;
extern ModelDefaultTypeInternal _Model_default_instance_;
class Point;
struct PointDefaultTypeInternal;
extern PointDefaultTypeInternal _Point_default_instance_;
class SystemRtState;
struct SystemRtStateDefaultTypeInternal;
extern SystemRtStateDefaultTypeInternal _SystemRtState_default_instance_;
class Tool;
struct ToolDefaultTypeInternal;
extern ToolDefaultTypeInternal _Tool_default_instance_;
class Wobj;
struct WobjDefaultTypeInternal;
extern WobjDefaultTypeInternal _Wobj_default_instance_;
}  // namespace system_rtstate
PROTOBUF_NAMESPACE_OPEN
template<> ::system_rtstate::Controller* Arena::CreateMaybeMessage<::system_rtstate::Controller>(Arena*);
template<> ::system_rtstate::Ftvalue* Arena::CreateMaybeMessage<::system_rtstate::Ftvalue>(Arena*);
template<> ::system_rtstate::Header* Arena::CreateMaybeMessage<::system_rtstate::Header>(Arena*);
template<> ::system_rtstate::Joint* Arena::CreateMaybeMessage<::system_rtstate::Joint>(Arena*);
template<> ::system_rtstate::Load* Arena::CreateMaybeMessage<::system_rtstate::Load>(Arena*);
template<> ::system_rtstate::Model* Arena::CreateMaybeMessage<::system_rtstate::Model>(Arena*);
template<> ::system_rtstate::Point* Arena::CreateMaybeMessage<::system_rtstate::Point>(Arena*);
template<> ::system_rtstate::SystemRtState* Arena::CreateMaybeMessage<::system_rtstate::SystemRtState>(Arena*);
template<> ::system_rtstate::Tool* Arena::CreateMaybeMessage<::system_rtstate::Tool>(Arena*);
template<> ::system_rtstate::Wobj* Arena::CreateMaybeMessage<::system_rtstate::Wobj>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace system_rtstate {

// ===================================================================

class Header final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:system_rtstate.Header) */ {
 public:
  inline Header() : Header(nullptr) {}
  ~Header() override;
  explicit PROTOBUF_CONSTEXPR Header(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Header(const Header& from);
  Header(Header&& from) noexcept
    : Header() {
    *this = ::std::move(from);
  }

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }
  inline Header& operator=(Header&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Header& default_instance() {
    return *internal_default_instance();
  }
  static inline const Header* internal_default_instance() {
    return reinterpret_cast<const Header*>(
               &_Header_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Header& a, Header& b) {
    a.Swap(&b);
  }
  inline void Swap(Header* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Header* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Header* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Header>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Header& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Header& from) {
    Header::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Header* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "system_rtstate.Header";
  }
  protected:
  explicit Header(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
    kFrameIdFieldNumber = 2,
  };
  // int64 timestamp = 1;
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // int64 frame_id = 2;
  void clear_frame_id();
  int64_t frame_id() const;
  void set_frame_id(int64_t value);
  private:
  int64_t _internal_frame_id() const;
  void _internal_set_frame_id(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:system_rtstate.Header)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t timestamp_;
    int64_t frame_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_overall_5fsystem_5frtstate_2eproto;
};
// -------------------------------------------------------------------

class Ftvalue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:system_rtstate.Ftvalue) */ {
 public:
  inline Ftvalue() : Ftvalue(nullptr) {}
  ~Ftvalue() override;
  explicit PROTOBUF_CONSTEXPR Ftvalue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Ftvalue(const Ftvalue& from);
  Ftvalue(Ftvalue&& from) noexcept
    : Ftvalue() {
    *this = ::std::move(from);
  }

  inline Ftvalue& operator=(const Ftvalue& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ftvalue& operator=(Ftvalue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Ftvalue& default_instance() {
    return *internal_default_instance();
  }
  static inline const Ftvalue* internal_default_instance() {
    return reinterpret_cast<const Ftvalue*>(
               &_Ftvalue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Ftvalue& a, Ftvalue& b) {
    a.Swap(&b);
  }
  inline void Swap(Ftvalue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ftvalue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Ftvalue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Ftvalue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Ftvalue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Ftvalue& from) {
    Ftvalue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ftvalue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "system_rtstate.Ftvalue";
  }
  protected:
  explicit Ftvalue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFxFieldNumber = 1,
    kFyFieldNumber = 2,
    kFzFieldNumber = 3,
    kMxFieldNumber = 4,
    kMyFieldNumber = 5,
    kMzFieldNumber = 6,
  };
  // double fx = 1;
  void clear_fx();
  double fx() const;
  void set_fx(double value);
  private:
  double _internal_fx() const;
  void _internal_set_fx(double value);
  public:

  // double fy = 2;
  void clear_fy();
  double fy() const;
  void set_fy(double value);
  private:
  double _internal_fy() const;
  void _internal_set_fy(double value);
  public:

  // double fz = 3;
  void clear_fz();
  double fz() const;
  void set_fz(double value);
  private:
  double _internal_fz() const;
  void _internal_set_fz(double value);
  public:

  // double mx = 4;
  void clear_mx();
  double mx() const;
  void set_mx(double value);
  private:
  double _internal_mx() const;
  void _internal_set_mx(double value);
  public:

  // double my = 5;
  void clear_my();
  double my() const;
  void set_my(double value);
  private:
  double _internal_my() const;
  void _internal_set_my(double value);
  public:

  // double mz = 6;
  void clear_mz();
  double mz() const;
  void set_mz(double value);
  private:
  double _internal_mz() const;
  void _internal_set_mz(double value);
  public:

  // @@protoc_insertion_point(class_scope:system_rtstate.Ftvalue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double fx_;
    double fy_;
    double fz_;
    double mx_;
    double my_;
    double mz_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_overall_5fsystem_5frtstate_2eproto;
};
// -------------------------------------------------------------------

class Controller final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:system_rtstate.Controller) */ {
 public:
  inline Controller() : Controller(nullptr) {}
  ~Controller() override;
  explicit PROTOBUF_CONSTEXPR Controller(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Controller(const Controller& from);
  Controller(Controller&& from) noexcept
    : Controller() {
    *this = ::std::move(from);
  }

  inline Controller& operator=(const Controller& from) {
    CopyFrom(from);
    return *this;
  }
  inline Controller& operator=(Controller&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Controller& default_instance() {
    return *internal_default_instance();
  }
  static inline const Controller* internal_default_instance() {
    return reinterpret_cast<const Controller*>(
               &_Controller_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Controller& a, Controller& b) {
    a.Swap(&b);
  }
  inline void Swap(Controller* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Controller* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Controller* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Controller>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Controller& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Controller& from) {
    Controller::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Controller* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "system_rtstate.Controller";
  }
  protected:
  explicit Controller(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFtvaluesFieldNumber = 6,
    kControllerNameFieldNumber = 1,
    kMasterInfoFieldNumber = 4,
    kControlCycleFieldNumber = 2,
    kGlobalCountFieldNumber = 3,
    kIsLinkUpFieldNumber = 5,
  };
  // repeated .system_rtstate.Ftvalue ftvalues = 6;
  int ftvalues_size() const;
  private:
  int _internal_ftvalues_size() const;
  public:
  void clear_ftvalues();
  ::system_rtstate::Ftvalue* mutable_ftvalues(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_rtstate::Ftvalue >*
      mutable_ftvalues();
  private:
  const ::system_rtstate::Ftvalue& _internal_ftvalues(int index) const;
  ::system_rtstate::Ftvalue* _internal_add_ftvalues();
  public:
  const ::system_rtstate::Ftvalue& ftvalues(int index) const;
  ::system_rtstate::Ftvalue* add_ftvalues();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_rtstate::Ftvalue >&
      ftvalues() const;

  // string controller_name = 1;
  void clear_controller_name();
  const std::string& controller_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_controller_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_controller_name();
  PROTOBUF_NODISCARD std::string* release_controller_name();
  void set_allocated_controller_name(std::string* controller_name);
  private:
  const std::string& _internal_controller_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_controller_name(const std::string& value);
  std::string* _internal_mutable_controller_name();
  public:

  // string master_info = 4;
  void clear_master_info();
  const std::string& master_info() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_master_info(ArgT0&& arg0, ArgT... args);
  std::string* mutable_master_info();
  PROTOBUF_NODISCARD std::string* release_master_info();
  void set_allocated_master_info(std::string* master_info);
  private:
  const std::string& _internal_master_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_master_info(const std::string& value);
  std::string* _internal_mutable_master_info();
  public:

  // double control_cycle = 2;
  void clear_control_cycle();
  double control_cycle() const;
  void set_control_cycle(double value);
  private:
  double _internal_control_cycle() const;
  void _internal_set_control_cycle(double value);
  public:

  // int64 global_count = 3;
  void clear_global_count();
  int64_t global_count() const;
  void set_global_count(int64_t value);
  private:
  int64_t _internal_global_count() const;
  void _internal_set_global_count(int64_t value);
  public:

  // bool is_link_up = 5;
  void clear_is_link_up();
  bool is_link_up() const;
  void set_is_link_up(bool value);
  private:
  bool _internal_is_link_up() const;
  void _internal_set_is_link_up(bool value);
  public:

  // @@protoc_insertion_point(class_scope:system_rtstate.Controller)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_rtstate::Ftvalue > ftvalues_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr controller_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr master_info_;
    double control_cycle_;
    int64_t global_count_;
    bool is_link_up_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_overall_5fsystem_5frtstate_2eproto;
};
// -------------------------------------------------------------------

class Joint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:system_rtstate.Joint) */ {
 public:
  inline Joint() : Joint(nullptr) {}
  ~Joint() override;
  explicit PROTOBUF_CONSTEXPR Joint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Joint(const Joint& from);
  Joint(Joint&& from) noexcept
    : Joint() {
    *this = ::std::move(from);
  }

  inline Joint& operator=(const Joint& from) {
    CopyFrom(from);
    return *this;
  }
  inline Joint& operator=(Joint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Joint& default_instance() {
    return *internal_default_instance();
  }
  static inline const Joint* internal_default_instance() {
    return reinterpret_cast<const Joint*>(
               &_Joint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Joint& a, Joint& b) {
    a.Swap(&b);
  }
  inline void Swap(Joint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Joint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Joint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Joint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Joint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Joint& from) {
    Joint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Joint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "system_rtstate.Joint";
  }
  protected:
  explicit Joint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJointTypeFieldNumber = 1,
    kPositionFieldNumber = 2,
    kTorqueFieldNumber = 3,
    kIsEnabledFieldNumber = 4,
    kModeFieldNumber = 5,
    kErrorCodeFieldNumber = 6,
    kDigitOutputFieldNumber = 7,
    kSensorTorqueFieldNumber = 9,
    kDigitInputFieldNumber = 8,
  };
  // string joint_type = 1;
  void clear_joint_type();
  const std::string& joint_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_joint_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_joint_type();
  PROTOBUF_NODISCARD std::string* release_joint_type();
  void set_allocated_joint_type(std::string* joint_type);
  private:
  const std::string& _internal_joint_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_joint_type(const std::string& value);
  std::string* _internal_mutable_joint_type();
  public:

  // double position = 2;
  void clear_position();
  double position() const;
  void set_position(double value);
  private:
  double _internal_position() const;
  void _internal_set_position(double value);
  public:

  // double torque = 3;
  void clear_torque();
  double torque() const;
  void set_torque(double value);
  private:
  double _internal_torque() const;
  void _internal_set_torque(double value);
  public:

  // bool is_enabled = 4;
  void clear_is_enabled();
  bool is_enabled() const;
  void set_is_enabled(bool value);
  private:
  bool _internal_is_enabled() const;
  void _internal_set_is_enabled(bool value);
  public:

  // int32 mode = 5;
  void clear_mode();
  int32_t mode() const;
  void set_mode(int32_t value);
  private:
  int32_t _internal_mode() const;
  void _internal_set_mode(int32_t value);
  public:

  // int32 error_code = 6;
  void clear_error_code();
  int32_t error_code() const;
  void set_error_code(int32_t value);
  private:
  int32_t _internal_error_code() const;
  void _internal_set_error_code(int32_t value);
  public:

  // int32 digit_output = 7;
  void clear_digit_output();
  int32_t digit_output() const;
  void set_digit_output(int32_t value);
  private:
  int32_t _internal_digit_output() const;
  void _internal_set_digit_output(int32_t value);
  public:

  // double sensor_torque = 9;
  void clear_sensor_torque();
  double sensor_torque() const;
  void set_sensor_torque(double value);
  private:
  double _internal_sensor_torque() const;
  void _internal_set_sensor_torque(double value);
  public:

  // int32 digit_input = 8;
  void clear_digit_input();
  int32_t digit_input() const;
  void set_digit_input(int32_t value);
  private:
  int32_t _internal_digit_input() const;
  void _internal_set_digit_input(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:system_rtstate.Joint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr joint_type_;
    double position_;
    double torque_;
    bool is_enabled_;
    int32_t mode_;
    int32_t error_code_;
    int32_t digit_output_;
    double sensor_torque_;
    int32_t digit_input_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_overall_5fsystem_5frtstate_2eproto;
};
// -------------------------------------------------------------------

class Tool final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:system_rtstate.Tool) */ {
 public:
  inline Tool() : Tool(nullptr) {}
  ~Tool() override;
  explicit PROTOBUF_CONSTEXPR Tool(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Tool(const Tool& from);
  Tool(Tool&& from) noexcept
    : Tool() {
    *this = ::std::move(from);
  }

  inline Tool& operator=(const Tool& from) {
    CopyFrom(from);
    return *this;
  }
  inline Tool& operator=(Tool&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Tool& default_instance() {
    return *internal_default_instance();
  }
  static inline const Tool* internal_default_instance() {
    return reinterpret_cast<const Tool*>(
               &_Tool_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Tool& a, Tool& b) {
    a.Swap(&b);
  }
  inline void Swap(Tool* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Tool* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Tool* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Tool>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Tool& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Tool& from) {
    Tool::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tool* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "system_rtstate.Tool";
  }
  protected:
  explicit Tool(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kToolNameFieldNumber = 1,
  };
  // repeated double data = 2;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  private:
  double _internal_data(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_data() const;
  void _internal_add_data(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_data();
  public:
  double data(int index) const;
  void set_data(int index, double value);
  void add_data(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_data();

  // string tool_name = 1;
  void clear_tool_name();
  const std::string& tool_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tool_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tool_name();
  PROTOBUF_NODISCARD std::string* release_tool_name();
  void set_allocated_tool_name(std::string* tool_name);
  private:
  const std::string& _internal_tool_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tool_name(const std::string& value);
  std::string* _internal_mutable_tool_name();
  public:

  // @@protoc_insertion_point(class_scope:system_rtstate.Tool)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tool_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_overall_5fsystem_5frtstate_2eproto;
};
// -------------------------------------------------------------------

class Wobj final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:system_rtstate.Wobj) */ {
 public:
  inline Wobj() : Wobj(nullptr) {}
  ~Wobj() override;
  explicit PROTOBUF_CONSTEXPR Wobj(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Wobj(const Wobj& from);
  Wobj(Wobj&& from) noexcept
    : Wobj() {
    *this = ::std::move(from);
  }

  inline Wobj& operator=(const Wobj& from) {
    CopyFrom(from);
    return *this;
  }
  inline Wobj& operator=(Wobj&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Wobj& default_instance() {
    return *internal_default_instance();
  }
  static inline const Wobj* internal_default_instance() {
    return reinterpret_cast<const Wobj*>(
               &_Wobj_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Wobj& a, Wobj& b) {
    a.Swap(&b);
  }
  inline void Swap(Wobj* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Wobj* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Wobj* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Wobj>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Wobj& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Wobj& from) {
    Wobj::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Wobj* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "system_rtstate.Wobj";
  }
  protected:
  explicit Wobj(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kWobjNameFieldNumber = 1,
  };
  // repeated double data = 2;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  private:
  double _internal_data(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_data() const;
  void _internal_add_data(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_data();
  public:
  double data(int index) const;
  void set_data(int index, double value);
  void add_data(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_data();

  // string wobj_name = 1;
  void clear_wobj_name();
  const std::string& wobj_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_wobj_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_wobj_name();
  PROTOBUF_NODISCARD std::string* release_wobj_name();
  void set_allocated_wobj_name(std::string* wobj_name);
  private:
  const std::string& _internal_wobj_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_wobj_name(const std::string& value);
  std::string* _internal_mutable_wobj_name();
  public:

  // @@protoc_insertion_point(class_scope:system_rtstate.Wobj)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr wobj_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_overall_5fsystem_5frtstate_2eproto;
};
// -------------------------------------------------------------------

class Load final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:system_rtstate.Load) */ {
 public:
  inline Load() : Load(nullptr) {}
  ~Load() override;
  explicit PROTOBUF_CONSTEXPR Load(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Load(const Load& from);
  Load(Load&& from) noexcept
    : Load() {
    *this = ::std::move(from);
  }

  inline Load& operator=(const Load& from) {
    CopyFrom(from);
    return *this;
  }
  inline Load& operator=(Load&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Load& default_instance() {
    return *internal_default_instance();
  }
  static inline const Load* internal_default_instance() {
    return reinterpret_cast<const Load*>(
               &_Load_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Load& a, Load& b) {
    a.Swap(&b);
  }
  inline void Swap(Load* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Load* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Load* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Load>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Load& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Load& from) {
    Load::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Load* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "system_rtstate.Load";
  }
  protected:
  explicit Load(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kLoadNameFieldNumber = 1,
  };
  // repeated double data = 2;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  private:
  double _internal_data(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_data() const;
  void _internal_add_data(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_data();
  public:
  double data(int index) const;
  void set_data(int index, double value);
  void add_data(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_data();

  // string load_name = 1;
  void clear_load_name();
  const std::string& load_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_load_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_load_name();
  PROTOBUF_NODISCARD std::string* release_load_name();
  void set_allocated_load_name(std::string* load_name);
  private:
  const std::string& _internal_load_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_load_name(const std::string& value);
  std::string* _internal_mutable_load_name();
  public:

  // @@protoc_insertion_point(class_scope:system_rtstate.Load)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr load_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_overall_5fsystem_5frtstate_2eproto;
};
// -------------------------------------------------------------------

class Point final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:system_rtstate.Point) */ {
 public:
  inline Point() : Point(nullptr) {}
  ~Point() override;
  explicit PROTOBUF_CONSTEXPR Point(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Point(const Point& from);
  Point(Point&& from) noexcept
    : Point() {
    *this = ::std::move(from);
  }

  inline Point& operator=(const Point& from) {
    CopyFrom(from);
    return *this;
  }
  inline Point& operator=(Point&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Point& default_instance() {
    return *internal_default_instance();
  }
  static inline const Point* internal_default_instance() {
    return reinterpret_cast<const Point*>(
               &_Point_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Point& a, Point& b) {
    a.Swap(&b);
  }
  inline void Swap(Point* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Point* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Point* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Point>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Point& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Point& from) {
    Point::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Point* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "system_rtstate.Point";
  }
  protected:
  explicit Point(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRobottargetFieldNumber = 4,
    kJointtargetFieldNumber = 5,
    kPointNameFieldNumber = 1,
    kToolFieldNumber = 2,
    kWobjFieldNumber = 3,
  };
  // repeated double robottarget = 4;
  int robottarget_size() const;
  private:
  int _internal_robottarget_size() const;
  public:
  void clear_robottarget();
  private:
  double _internal_robottarget(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_robottarget() const;
  void _internal_add_robottarget(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_robottarget();
  public:
  double robottarget(int index) const;
  void set_robottarget(int index, double value);
  void add_robottarget(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      robottarget() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_robottarget();

  // repeated double jointtarget = 5;
  int jointtarget_size() const;
  private:
  int _internal_jointtarget_size() const;
  public:
  void clear_jointtarget();
  private:
  double _internal_jointtarget(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_jointtarget() const;
  void _internal_add_jointtarget(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_jointtarget();
  public:
  double jointtarget(int index) const;
  void set_jointtarget(int index, double value);
  void add_jointtarget(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      jointtarget() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_jointtarget();

  // string point_name = 1;
  void clear_point_name();
  const std::string& point_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_point_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_point_name();
  PROTOBUF_NODISCARD std::string* release_point_name();
  void set_allocated_point_name(std::string* point_name);
  private:
  const std::string& _internal_point_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_point_name(const std::string& value);
  std::string* _internal_mutable_point_name();
  public:

  // .system_rtstate.Tool tool = 2;
  bool has_tool() const;
  private:
  bool _internal_has_tool() const;
  public:
  void clear_tool();
  const ::system_rtstate::Tool& tool() const;
  PROTOBUF_NODISCARD ::system_rtstate::Tool* release_tool();
  ::system_rtstate::Tool* mutable_tool();
  void set_allocated_tool(::system_rtstate::Tool* tool);
  private:
  const ::system_rtstate::Tool& _internal_tool() const;
  ::system_rtstate::Tool* _internal_mutable_tool();
  public:
  void unsafe_arena_set_allocated_tool(
      ::system_rtstate::Tool* tool);
  ::system_rtstate::Tool* unsafe_arena_release_tool();

  // .system_rtstate.Wobj wobj = 3;
  bool has_wobj() const;
  private:
  bool _internal_has_wobj() const;
  public:
  void clear_wobj();
  const ::system_rtstate::Wobj& wobj() const;
  PROTOBUF_NODISCARD ::system_rtstate::Wobj* release_wobj();
  ::system_rtstate::Wobj* mutable_wobj();
  void set_allocated_wobj(::system_rtstate::Wobj* wobj);
  private:
  const ::system_rtstate::Wobj& _internal_wobj() const;
  ::system_rtstate::Wobj* _internal_mutable_wobj();
  public:
  void unsafe_arena_set_allocated_wobj(
      ::system_rtstate::Wobj* wobj);
  ::system_rtstate::Wobj* unsafe_arena_release_wobj();

  // @@protoc_insertion_point(class_scope:system_rtstate.Point)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > robottarget_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > jointtarget_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr point_name_;
    ::system_rtstate::Tool* tool_;
    ::system_rtstate::Wobj* wobj_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_overall_5fsystem_5frtstate_2eproto;
};
// -------------------------------------------------------------------

class Model final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:system_rtstate.Model) */ {
 public:
  inline Model() : Model(nullptr) {}
  ~Model() override;
  explicit PROTOBUF_CONSTEXPR Model(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Model(const Model& from);
  Model(Model&& from) noexcept
    : Model() {
    *this = ::std::move(from);
  }

  inline Model& operator=(const Model& from) {
    CopyFrom(from);
    return *this;
  }
  inline Model& operator=(Model&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Model& default_instance() {
    return *internal_default_instance();
  }
  static inline const Model* internal_default_instance() {
    return reinterpret_cast<const Model*>(
               &_Model_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Model& a, Model& b) {
    a.Swap(&b);
  }
  inline void Swap(Model* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Model* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Model* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Model>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Model& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Model& from) {
    Model::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Model* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "system_rtstate.Model";
  }
  protected:
  explicit Model(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJointFieldNumber = 3,
    kEePe321FieldNumber = 13,
    kModelNameFieldNumber = 1,
    kModelTypeFieldNumber = 2,
    kErrorMsgFieldNumber = 6,
    kCurrentFuncNameFieldNumber = 9,
    kCurrentFuncInfoFieldNumber = 10,
    kInfoMsgFieldNumber = 12,
    kCurrentPointFieldNumber = 4,
    kErrorCodeFieldNumber = 5,
    kModelStateFieldNumber = 7,
    kModelTimeRateFieldNumber = 8,
    kFuncCountFieldNumber = 11,
  };
  // repeated .system_rtstate.Joint joint = 3;
  int joint_size() const;
  private:
  int _internal_joint_size() const;
  public:
  void clear_joint();
  ::system_rtstate::Joint* mutable_joint(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_rtstate::Joint >*
      mutable_joint();
  private:
  const ::system_rtstate::Joint& _internal_joint(int index) const;
  ::system_rtstate::Joint* _internal_add_joint();
  public:
  const ::system_rtstate::Joint& joint(int index) const;
  ::system_rtstate::Joint* add_joint();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_rtstate::Joint >&
      joint() const;

  // repeated double ee_pe321 = 13;
  int ee_pe321_size() const;
  private:
  int _internal_ee_pe321_size() const;
  public:
  void clear_ee_pe321();
  private:
  double _internal_ee_pe321(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_ee_pe321() const;
  void _internal_add_ee_pe321(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_ee_pe321();
  public:
  double ee_pe321(int index) const;
  void set_ee_pe321(int index, double value);
  void add_ee_pe321(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      ee_pe321() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_ee_pe321();

  // string model_name = 1;
  void clear_model_name();
  const std::string& model_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_name();
  PROTOBUF_NODISCARD std::string* release_model_name();
  void set_allocated_model_name(std::string* model_name);
  private:
  const std::string& _internal_model_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_name(const std::string& value);
  std::string* _internal_mutable_model_name();
  public:

  // string model_type = 2;
  void clear_model_type();
  const std::string& model_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_type();
  PROTOBUF_NODISCARD std::string* release_model_type();
  void set_allocated_model_type(std::string* model_type);
  private:
  const std::string& _internal_model_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_type(const std::string& value);
  std::string* _internal_mutable_model_type();
  public:

  // string error_msg = 6;
  void clear_error_msg();
  const std::string& error_msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_msg();
  PROTOBUF_NODISCARD std::string* release_error_msg();
  void set_allocated_error_msg(std::string* error_msg);
  private:
  const std::string& _internal_error_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_msg(const std::string& value);
  std::string* _internal_mutable_error_msg();
  public:

  // string current_func_name = 9;
  void clear_current_func_name();
  const std::string& current_func_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_current_func_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_current_func_name();
  PROTOBUF_NODISCARD std::string* release_current_func_name();
  void set_allocated_current_func_name(std::string* current_func_name);
  private:
  const std::string& _internal_current_func_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_current_func_name(const std::string& value);
  std::string* _internal_mutable_current_func_name();
  public:

  // string current_func_info = 10;
  void clear_current_func_info();
  const std::string& current_func_info() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_current_func_info(ArgT0&& arg0, ArgT... args);
  std::string* mutable_current_func_info();
  PROTOBUF_NODISCARD std::string* release_current_func_info();
  void set_allocated_current_func_info(std::string* current_func_info);
  private:
  const std::string& _internal_current_func_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_current_func_info(const std::string& value);
  std::string* _internal_mutable_current_func_info();
  public:

  // string info_msg = 12;
  void clear_info_msg();
  const std::string& info_msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_info_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_info_msg();
  PROTOBUF_NODISCARD std::string* release_info_msg();
  void set_allocated_info_msg(std::string* info_msg);
  private:
  const std::string& _internal_info_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_info_msg(const std::string& value);
  std::string* _internal_mutable_info_msg();
  public:

  // .system_rtstate.Point current_point = 4;
  bool has_current_point() const;
  private:
  bool _internal_has_current_point() const;
  public:
  void clear_current_point();
  const ::system_rtstate::Point& current_point() const;
  PROTOBUF_NODISCARD ::system_rtstate::Point* release_current_point();
  ::system_rtstate::Point* mutable_current_point();
  void set_allocated_current_point(::system_rtstate::Point* current_point);
  private:
  const ::system_rtstate::Point& _internal_current_point() const;
  ::system_rtstate::Point* _internal_mutable_current_point();
  public:
  void unsafe_arena_set_allocated_current_point(
      ::system_rtstate::Point* current_point);
  ::system_rtstate::Point* unsafe_arena_release_current_point();

  // int32 error_code = 5;
  void clear_error_code();
  int32_t error_code() const;
  void set_error_code(int32_t value);
  private:
  int32_t _internal_error_code() const;
  void _internal_set_error_code(int32_t value);
  public:

  // int32 model_state = 7;
  void clear_model_state();
  int32_t model_state() const;
  void set_model_state(int32_t value);
  private:
  int32_t _internal_model_state() const;
  void _internal_set_model_state(int32_t value);
  public:

  // double model_time_rate = 8;
  void clear_model_time_rate();
  double model_time_rate() const;
  void set_model_time_rate(double value);
  private:
  double _internal_model_time_rate() const;
  void _internal_set_model_time_rate(double value);
  public:

  // int32 func_count = 11;
  void clear_func_count();
  int32_t func_count() const;
  void set_func_count(int32_t value);
  private:
  int32_t _internal_func_count() const;
  void _internal_set_func_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:system_rtstate.Model)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_rtstate::Joint > joint_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > ee_pe321_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_msg_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr current_func_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr current_func_info_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr info_msg_;
    ::system_rtstate::Point* current_point_;
    int32_t error_code_;
    int32_t model_state_;
    double model_time_rate_;
    int32_t func_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_overall_5fsystem_5frtstate_2eproto;
};
// -------------------------------------------------------------------

class SystemRtState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:system_rtstate.SystemRtState) */ {
 public:
  inline SystemRtState() : SystemRtState(nullptr) {}
  ~SystemRtState() override;
  explicit PROTOBUF_CONSTEXPR SystemRtState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SystemRtState(const SystemRtState& from);
  SystemRtState(SystemRtState&& from) noexcept
    : SystemRtState() {
    *this = ::std::move(from);
  }

  inline SystemRtState& operator=(const SystemRtState& from) {
    CopyFrom(from);
    return *this;
  }
  inline SystemRtState& operator=(SystemRtState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SystemRtState& default_instance() {
    return *internal_default_instance();
  }
  static inline const SystemRtState* internal_default_instance() {
    return reinterpret_cast<const SystemRtState*>(
               &_SystemRtState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SystemRtState& a, SystemRtState& b) {
    a.Swap(&b);
  }
  inline void Swap(SystemRtState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SystemRtState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SystemRtState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SystemRtState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SystemRtState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SystemRtState& from) {
    SystemRtState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SystemRtState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "system_rtstate.SystemRtState";
  }
  protected:
  explicit SystemRtState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelFieldNumber = 3,
    kHeadFieldNumber = 1,
    kControllerFieldNumber = 4,
    kSystemRunningStateFieldNumber = 2,
  };
  // repeated .system_rtstate.Model model = 3;
  int model_size() const;
  private:
  int _internal_model_size() const;
  public:
  void clear_model();
  ::system_rtstate::Model* mutable_model(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_rtstate::Model >*
      mutable_model();
  private:
  const ::system_rtstate::Model& _internal_model(int index) const;
  ::system_rtstate::Model* _internal_add_model();
  public:
  const ::system_rtstate::Model& model(int index) const;
  ::system_rtstate::Model* add_model();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_rtstate::Model >&
      model() const;

  // .system_rtstate.Header head = 1;
  bool has_head() const;
  private:
  bool _internal_has_head() const;
  public:
  void clear_head();
  const ::system_rtstate::Header& head() const;
  PROTOBUF_NODISCARD ::system_rtstate::Header* release_head();
  ::system_rtstate::Header* mutable_head();
  void set_allocated_head(::system_rtstate::Header* head);
  private:
  const ::system_rtstate::Header& _internal_head() const;
  ::system_rtstate::Header* _internal_mutable_head();
  public:
  void unsafe_arena_set_allocated_head(
      ::system_rtstate::Header* head);
  ::system_rtstate::Header* unsafe_arena_release_head();

  // .system_rtstate.Controller controller = 4;
  bool has_controller() const;
  private:
  bool _internal_has_controller() const;
  public:
  void clear_controller();
  const ::system_rtstate::Controller& controller() const;
  PROTOBUF_NODISCARD ::system_rtstate::Controller* release_controller();
  ::system_rtstate::Controller* mutable_controller();
  void set_allocated_controller(::system_rtstate::Controller* controller);
  private:
  const ::system_rtstate::Controller& _internal_controller() const;
  ::system_rtstate::Controller* _internal_mutable_controller();
  public:
  void unsafe_arena_set_allocated_controller(
      ::system_rtstate::Controller* controller);
  ::system_rtstate::Controller* unsafe_arena_release_controller();

  // bool system_running_state = 2;
  void clear_system_running_state();
  bool system_running_state() const;
  void set_system_running_state(bool value);
  private:
  bool _internal_system_running_state() const;
  void _internal_set_system_running_state(bool value);
  public:

  // @@protoc_insertion_point(class_scope:system_rtstate.SystemRtState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_rtstate::Model > model_;
    ::system_rtstate::Header* head_;
    ::system_rtstate::Controller* controller_;
    bool system_running_state_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_overall_5fsystem_5frtstate_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Header

// int64 timestamp = 1;
inline void Header::clear_timestamp() {
  _impl_.timestamp_ = int64_t{0};
}
inline int64_t Header::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline int64_t Header::timestamp() const {
  // @@protoc_insertion_point(field_get:system_rtstate.Header.timestamp)
  return _internal_timestamp();
}
inline void Header::_internal_set_timestamp(int64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void Header::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:system_rtstate.Header.timestamp)
}

// int64 frame_id = 2;
inline void Header::clear_frame_id() {
  _impl_.frame_id_ = int64_t{0};
}
inline int64_t Header::_internal_frame_id() const {
  return _impl_.frame_id_;
}
inline int64_t Header::frame_id() const {
  // @@protoc_insertion_point(field_get:system_rtstate.Header.frame_id)
  return _internal_frame_id();
}
inline void Header::_internal_set_frame_id(int64_t value) {
  
  _impl_.frame_id_ = value;
}
inline void Header::set_frame_id(int64_t value) {
  _internal_set_frame_id(value);
  // @@protoc_insertion_point(field_set:system_rtstate.Header.frame_id)
}

// -------------------------------------------------------------------

// Ftvalue

// double fx = 1;
inline void Ftvalue::clear_fx() {
  _impl_.fx_ = 0;
}
inline double Ftvalue::_internal_fx() const {
  return _impl_.fx_;
}
inline double Ftvalue::fx() const {
  // @@protoc_insertion_point(field_get:system_rtstate.Ftvalue.fx)
  return _internal_fx();
}
inline void Ftvalue::_internal_set_fx(double value) {
  
  _impl_.fx_ = value;
}
inline void Ftvalue::set_fx(double value) {
  _internal_set_fx(value);
  // @@protoc_insertion_point(field_set:system_rtstate.Ftvalue.fx)
}

// double fy = 2;
inline void Ftvalue::clear_fy() {
  _impl_.fy_ = 0;
}
inline double Ftvalue::_internal_fy() const {
  return _impl_.fy_;
}
inline double Ftvalue::fy() const {
  // @@protoc_insertion_point(field_get:system_rtstate.Ftvalue.fy)
  return _internal_fy();
}
inline void Ftvalue::_internal_set_fy(double value) {
  
  _impl_.fy_ = value;
}
inline void Ftvalue::set_fy(double value) {
  _internal_set_fy(value);
  // @@protoc_insertion_point(field_set:system_rtstate.Ftvalue.fy)
}

// double fz = 3;
inline void Ftvalue::clear_fz() {
  _impl_.fz_ = 0;
}
inline double Ftvalue::_internal_fz() const {
  return _impl_.fz_;
}
inline double Ftvalue::fz() const {
  // @@protoc_insertion_point(field_get:system_rtstate.Ftvalue.fz)
  return _internal_fz();
}
inline void Ftvalue::_internal_set_fz(double value) {
  
  _impl_.fz_ = value;
}
inline void Ftvalue::set_fz(double value) {
  _internal_set_fz(value);
  // @@protoc_insertion_point(field_set:system_rtstate.Ftvalue.fz)
}

// double mx = 4;
inline void Ftvalue::clear_mx() {
  _impl_.mx_ = 0;
}
inline double Ftvalue::_internal_mx() const {
  return _impl_.mx_;
}
inline double Ftvalue::mx() const {
  // @@protoc_insertion_point(field_get:system_rtstate.Ftvalue.mx)
  return _internal_mx();
}
inline void Ftvalue::_internal_set_mx(double value) {
  
  _impl_.mx_ = value;
}
inline void Ftvalue::set_mx(double value) {
  _internal_set_mx(value);
  // @@protoc_insertion_point(field_set:system_rtstate.Ftvalue.mx)
}

// double my = 5;
inline void Ftvalue::clear_my() {
  _impl_.my_ = 0;
}
inline double Ftvalue::_internal_my() const {
  return _impl_.my_;
}
inline double Ftvalue::my() const {
  // @@protoc_insertion_point(field_get:system_rtstate.Ftvalue.my)
  return _internal_my();
}
inline void Ftvalue::_internal_set_my(double value) {
  
  _impl_.my_ = value;
}
inline void Ftvalue::set_my(double value) {
  _internal_set_my(value);
  // @@protoc_insertion_point(field_set:system_rtstate.Ftvalue.my)
}

// double mz = 6;
inline void Ftvalue::clear_mz() {
  _impl_.mz_ = 0;
}
inline double Ftvalue::_internal_mz() const {
  return _impl_.mz_;
}
inline double Ftvalue::mz() const {
  // @@protoc_insertion_point(field_get:system_rtstate.Ftvalue.mz)
  return _internal_mz();
}
inline void Ftvalue::_internal_set_mz(double value) {
  
  _impl_.mz_ = value;
}
inline void Ftvalue::set_mz(double value) {
  _internal_set_mz(value);
  // @@protoc_insertion_point(field_set:system_rtstate.Ftvalue.mz)
}

// -------------------------------------------------------------------

// Controller

// string controller_name = 1;
inline void Controller::clear_controller_name() {
  _impl_.controller_name_.ClearToEmpty();
}
inline const std::string& Controller::controller_name() const {
  // @@protoc_insertion_point(field_get:system_rtstate.Controller.controller_name)
  return _internal_controller_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Controller::set_controller_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.controller_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:system_rtstate.Controller.controller_name)
}
inline std::string* Controller::mutable_controller_name() {
  std::string* _s = _internal_mutable_controller_name();
  // @@protoc_insertion_point(field_mutable:system_rtstate.Controller.controller_name)
  return _s;
}
inline const std::string& Controller::_internal_controller_name() const {
  return _impl_.controller_name_.Get();
}
inline void Controller::_internal_set_controller_name(const std::string& value) {
  
  _impl_.controller_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Controller::_internal_mutable_controller_name() {
  
  return _impl_.controller_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Controller::release_controller_name() {
  // @@protoc_insertion_point(field_release:system_rtstate.Controller.controller_name)
  return _impl_.controller_name_.Release();
}
inline void Controller::set_allocated_controller_name(std::string* controller_name) {
  if (controller_name != nullptr) {
    
  } else {
    
  }
  _impl_.controller_name_.SetAllocated(controller_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.controller_name_.IsDefault()) {
    _impl_.controller_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:system_rtstate.Controller.controller_name)
}

// double control_cycle = 2;
inline void Controller::clear_control_cycle() {
  _impl_.control_cycle_ = 0;
}
inline double Controller::_internal_control_cycle() const {
  return _impl_.control_cycle_;
}
inline double Controller::control_cycle() const {
  // @@protoc_insertion_point(field_get:system_rtstate.Controller.control_cycle)
  return _internal_control_cycle();
}
inline void Controller::_internal_set_control_cycle(double value) {
  
  _impl_.control_cycle_ = value;
}
inline void Controller::set_control_cycle(double value) {
  _internal_set_control_cycle(value);
  // @@protoc_insertion_point(field_set:system_rtstate.Controller.control_cycle)
}

// int64 global_count = 3;
inline void Controller::clear_global_count() {
  _impl_.global_count_ = int64_t{0};
}
inline int64_t Controller::_internal_global_count() const {
  return _impl_.global_count_;
}
inline int64_t Controller::global_count() const {
  // @@protoc_insertion_point(field_get:system_rtstate.Controller.global_count)
  return _internal_global_count();
}
inline void Controller::_internal_set_global_count(int64_t value) {
  
  _impl_.global_count_ = value;
}
inline void Controller::set_global_count(int64_t value) {
  _internal_set_global_count(value);
  // @@protoc_insertion_point(field_set:system_rtstate.Controller.global_count)
}

// string master_info = 4;
inline void Controller::clear_master_info() {
  _impl_.master_info_.ClearToEmpty();
}
inline const std::string& Controller::master_info() const {
  // @@protoc_insertion_point(field_get:system_rtstate.Controller.master_info)
  return _internal_master_info();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Controller::set_master_info(ArgT0&& arg0, ArgT... args) {
 
 _impl_.master_info_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:system_rtstate.Controller.master_info)
}
inline std::string* Controller::mutable_master_info() {
  std::string* _s = _internal_mutable_master_info();
  // @@protoc_insertion_point(field_mutable:system_rtstate.Controller.master_info)
  return _s;
}
inline const std::string& Controller::_internal_master_info() const {
  return _impl_.master_info_.Get();
}
inline void Controller::_internal_set_master_info(const std::string& value) {
  
  _impl_.master_info_.Set(value, GetArenaForAllocation());
}
inline std::string* Controller::_internal_mutable_master_info() {
  
  return _impl_.master_info_.Mutable(GetArenaForAllocation());
}
inline std::string* Controller::release_master_info() {
  // @@protoc_insertion_point(field_release:system_rtstate.Controller.master_info)
  return _impl_.master_info_.Release();
}
inline void Controller::set_allocated_master_info(std::string* master_info) {
  if (master_info != nullptr) {
    
  } else {
    
  }
  _impl_.master_info_.SetAllocated(master_info, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.master_info_.IsDefault()) {
    _impl_.master_info_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:system_rtstate.Controller.master_info)
}

// bool is_link_up = 5;
inline void Controller::clear_is_link_up() {
  _impl_.is_link_up_ = false;
}
inline bool Controller::_internal_is_link_up() const {
  return _impl_.is_link_up_;
}
inline bool Controller::is_link_up() const {
  // @@protoc_insertion_point(field_get:system_rtstate.Controller.is_link_up)
  return _internal_is_link_up();
}
inline void Controller::_internal_set_is_link_up(bool value) {
  
  _impl_.is_link_up_ = value;
}
inline void Controller::set_is_link_up(bool value) {
  _internal_set_is_link_up(value);
  // @@protoc_insertion_point(field_set:system_rtstate.Controller.is_link_up)
}

// repeated .system_rtstate.Ftvalue ftvalues = 6;
inline int Controller::_internal_ftvalues_size() const {
  return _impl_.ftvalues_.size();
}
inline int Controller::ftvalues_size() const {
  return _internal_ftvalues_size();
}
inline void Controller::clear_ftvalues() {
  _impl_.ftvalues_.Clear();
}
inline ::system_rtstate::Ftvalue* Controller::mutable_ftvalues(int index) {
  // @@protoc_insertion_point(field_mutable:system_rtstate.Controller.ftvalues)
  return _impl_.ftvalues_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_rtstate::Ftvalue >*
Controller::mutable_ftvalues() {
  // @@protoc_insertion_point(field_mutable_list:system_rtstate.Controller.ftvalues)
  return &_impl_.ftvalues_;
}
inline const ::system_rtstate::Ftvalue& Controller::_internal_ftvalues(int index) const {
  return _impl_.ftvalues_.Get(index);
}
inline const ::system_rtstate::Ftvalue& Controller::ftvalues(int index) const {
  // @@protoc_insertion_point(field_get:system_rtstate.Controller.ftvalues)
  return _internal_ftvalues(index);
}
inline ::system_rtstate::Ftvalue* Controller::_internal_add_ftvalues() {
  return _impl_.ftvalues_.Add();
}
inline ::system_rtstate::Ftvalue* Controller::add_ftvalues() {
  ::system_rtstate::Ftvalue* _add = _internal_add_ftvalues();
  // @@protoc_insertion_point(field_add:system_rtstate.Controller.ftvalues)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_rtstate::Ftvalue >&
Controller::ftvalues() const {
  // @@protoc_insertion_point(field_list:system_rtstate.Controller.ftvalues)
  return _impl_.ftvalues_;
}

// -------------------------------------------------------------------

// Joint

// string joint_type = 1;
inline void Joint::clear_joint_type() {
  _impl_.joint_type_.ClearToEmpty();
}
inline const std::string& Joint::joint_type() const {
  // @@protoc_insertion_point(field_get:system_rtstate.Joint.joint_type)
  return _internal_joint_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Joint::set_joint_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.joint_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:system_rtstate.Joint.joint_type)
}
inline std::string* Joint::mutable_joint_type() {
  std::string* _s = _internal_mutable_joint_type();
  // @@protoc_insertion_point(field_mutable:system_rtstate.Joint.joint_type)
  return _s;
}
inline const std::string& Joint::_internal_joint_type() const {
  return _impl_.joint_type_.Get();
}
inline void Joint::_internal_set_joint_type(const std::string& value) {
  
  _impl_.joint_type_.Set(value, GetArenaForAllocation());
}
inline std::string* Joint::_internal_mutable_joint_type() {
  
  return _impl_.joint_type_.Mutable(GetArenaForAllocation());
}
inline std::string* Joint::release_joint_type() {
  // @@protoc_insertion_point(field_release:system_rtstate.Joint.joint_type)
  return _impl_.joint_type_.Release();
}
inline void Joint::set_allocated_joint_type(std::string* joint_type) {
  if (joint_type != nullptr) {
    
  } else {
    
  }
  _impl_.joint_type_.SetAllocated(joint_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.joint_type_.IsDefault()) {
    _impl_.joint_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:system_rtstate.Joint.joint_type)
}

// double position = 2;
inline void Joint::clear_position() {
  _impl_.position_ = 0;
}
inline double Joint::_internal_position() const {
  return _impl_.position_;
}
inline double Joint::position() const {
  // @@protoc_insertion_point(field_get:system_rtstate.Joint.position)
  return _internal_position();
}
inline void Joint::_internal_set_position(double value) {
  
  _impl_.position_ = value;
}
inline void Joint::set_position(double value) {
  _internal_set_position(value);
  // @@protoc_insertion_point(field_set:system_rtstate.Joint.position)
}

// double torque = 3;
inline void Joint::clear_torque() {
  _impl_.torque_ = 0;
}
inline double Joint::_internal_torque() const {
  return _impl_.torque_;
}
inline double Joint::torque() const {
  // @@protoc_insertion_point(field_get:system_rtstate.Joint.torque)
  return _internal_torque();
}
inline void Joint::_internal_set_torque(double value) {
  
  _impl_.torque_ = value;
}
inline void Joint::set_torque(double value) {
  _internal_set_torque(value);
  // @@protoc_insertion_point(field_set:system_rtstate.Joint.torque)
}

// bool is_enabled = 4;
inline void Joint::clear_is_enabled() {
  _impl_.is_enabled_ = false;
}
inline bool Joint::_internal_is_enabled() const {
  return _impl_.is_enabled_;
}
inline bool Joint::is_enabled() const {
  // @@protoc_insertion_point(field_get:system_rtstate.Joint.is_enabled)
  return _internal_is_enabled();
}
inline void Joint::_internal_set_is_enabled(bool value) {
  
  _impl_.is_enabled_ = value;
}
inline void Joint::set_is_enabled(bool value) {
  _internal_set_is_enabled(value);
  // @@protoc_insertion_point(field_set:system_rtstate.Joint.is_enabled)
}

// int32 mode = 5;
inline void Joint::clear_mode() {
  _impl_.mode_ = 0;
}
inline int32_t Joint::_internal_mode() const {
  return _impl_.mode_;
}
inline int32_t Joint::mode() const {
  // @@protoc_insertion_point(field_get:system_rtstate.Joint.mode)
  return _internal_mode();
}
inline void Joint::_internal_set_mode(int32_t value) {
  
  _impl_.mode_ = value;
}
inline void Joint::set_mode(int32_t value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:system_rtstate.Joint.mode)
}

// int32 error_code = 6;
inline void Joint::clear_error_code() {
  _impl_.error_code_ = 0;
}
inline int32_t Joint::_internal_error_code() const {
  return _impl_.error_code_;
}
inline int32_t Joint::error_code() const {
  // @@protoc_insertion_point(field_get:system_rtstate.Joint.error_code)
  return _internal_error_code();
}
inline void Joint::_internal_set_error_code(int32_t value) {
  
  _impl_.error_code_ = value;
}
inline void Joint::set_error_code(int32_t value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:system_rtstate.Joint.error_code)
}

// int32 digit_output = 7;
inline void Joint::clear_digit_output() {
  _impl_.digit_output_ = 0;
}
inline int32_t Joint::_internal_digit_output() const {
  return _impl_.digit_output_;
}
inline int32_t Joint::digit_output() const {
  // @@protoc_insertion_point(field_get:system_rtstate.Joint.digit_output)
  return _internal_digit_output();
}
inline void Joint::_internal_set_digit_output(int32_t value) {
  
  _impl_.digit_output_ = value;
}
inline void Joint::set_digit_output(int32_t value) {
  _internal_set_digit_output(value);
  // @@protoc_insertion_point(field_set:system_rtstate.Joint.digit_output)
}

// int32 digit_input = 8;
inline void Joint::clear_digit_input() {
  _impl_.digit_input_ = 0;
}
inline int32_t Joint::_internal_digit_input() const {
  return _impl_.digit_input_;
}
inline int32_t Joint::digit_input() const {
  // @@protoc_insertion_point(field_get:system_rtstate.Joint.digit_input)
  return _internal_digit_input();
}
inline void Joint::_internal_set_digit_input(int32_t value) {
  
  _impl_.digit_input_ = value;
}
inline void Joint::set_digit_input(int32_t value) {
  _internal_set_digit_input(value);
  // @@protoc_insertion_point(field_set:system_rtstate.Joint.digit_input)
}

// double sensor_torque = 9;
inline void Joint::clear_sensor_torque() {
  _impl_.sensor_torque_ = 0;
}
inline double Joint::_internal_sensor_torque() const {
  return _impl_.sensor_torque_;
}
inline double Joint::sensor_torque() const {
  // @@protoc_insertion_point(field_get:system_rtstate.Joint.sensor_torque)
  return _internal_sensor_torque();
}
inline void Joint::_internal_set_sensor_torque(double value) {
  
  _impl_.sensor_torque_ = value;
}
inline void Joint::set_sensor_torque(double value) {
  _internal_set_sensor_torque(value);
  // @@protoc_insertion_point(field_set:system_rtstate.Joint.sensor_torque)
}

// -------------------------------------------------------------------

// Tool

// string tool_name = 1;
inline void Tool::clear_tool_name() {
  _impl_.tool_name_.ClearToEmpty();
}
inline const std::string& Tool::tool_name() const {
  // @@protoc_insertion_point(field_get:system_rtstate.Tool.tool_name)
  return _internal_tool_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Tool::set_tool_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tool_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:system_rtstate.Tool.tool_name)
}
inline std::string* Tool::mutable_tool_name() {
  std::string* _s = _internal_mutable_tool_name();
  // @@protoc_insertion_point(field_mutable:system_rtstate.Tool.tool_name)
  return _s;
}
inline const std::string& Tool::_internal_tool_name() const {
  return _impl_.tool_name_.Get();
}
inline void Tool::_internal_set_tool_name(const std::string& value) {
  
  _impl_.tool_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Tool::_internal_mutable_tool_name() {
  
  return _impl_.tool_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Tool::release_tool_name() {
  // @@protoc_insertion_point(field_release:system_rtstate.Tool.tool_name)
  return _impl_.tool_name_.Release();
}
inline void Tool::set_allocated_tool_name(std::string* tool_name) {
  if (tool_name != nullptr) {
    
  } else {
    
  }
  _impl_.tool_name_.SetAllocated(tool_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tool_name_.IsDefault()) {
    _impl_.tool_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:system_rtstate.Tool.tool_name)
}

// repeated double data = 2;
inline int Tool::_internal_data_size() const {
  return _impl_.data_.size();
}
inline int Tool::data_size() const {
  return _internal_data_size();
}
inline void Tool::clear_data() {
  _impl_.data_.Clear();
}
inline double Tool::_internal_data(int index) const {
  return _impl_.data_.Get(index);
}
inline double Tool::data(int index) const {
  // @@protoc_insertion_point(field_get:system_rtstate.Tool.data)
  return _internal_data(index);
}
inline void Tool::set_data(int index, double value) {
  _impl_.data_.Set(index, value);
  // @@protoc_insertion_point(field_set:system_rtstate.Tool.data)
}
inline void Tool::_internal_add_data(double value) {
  _impl_.data_.Add(value);
}
inline void Tool::add_data(double value) {
  _internal_add_data(value);
  // @@protoc_insertion_point(field_add:system_rtstate.Tool.data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
Tool::_internal_data() const {
  return _impl_.data_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
Tool::data() const {
  // @@protoc_insertion_point(field_list:system_rtstate.Tool.data)
  return _internal_data();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
Tool::_internal_mutable_data() {
  return &_impl_.data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
Tool::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:system_rtstate.Tool.data)
  return _internal_mutable_data();
}

// -------------------------------------------------------------------

// Wobj

// string wobj_name = 1;
inline void Wobj::clear_wobj_name() {
  _impl_.wobj_name_.ClearToEmpty();
}
inline const std::string& Wobj::wobj_name() const {
  // @@protoc_insertion_point(field_get:system_rtstate.Wobj.wobj_name)
  return _internal_wobj_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Wobj::set_wobj_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.wobj_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:system_rtstate.Wobj.wobj_name)
}
inline std::string* Wobj::mutable_wobj_name() {
  std::string* _s = _internal_mutable_wobj_name();
  // @@protoc_insertion_point(field_mutable:system_rtstate.Wobj.wobj_name)
  return _s;
}
inline const std::string& Wobj::_internal_wobj_name() const {
  return _impl_.wobj_name_.Get();
}
inline void Wobj::_internal_set_wobj_name(const std::string& value) {
  
  _impl_.wobj_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Wobj::_internal_mutable_wobj_name() {
  
  return _impl_.wobj_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Wobj::release_wobj_name() {
  // @@protoc_insertion_point(field_release:system_rtstate.Wobj.wobj_name)
  return _impl_.wobj_name_.Release();
}
inline void Wobj::set_allocated_wobj_name(std::string* wobj_name) {
  if (wobj_name != nullptr) {
    
  } else {
    
  }
  _impl_.wobj_name_.SetAllocated(wobj_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.wobj_name_.IsDefault()) {
    _impl_.wobj_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:system_rtstate.Wobj.wobj_name)
}

// repeated double data = 2;
inline int Wobj::_internal_data_size() const {
  return _impl_.data_.size();
}
inline int Wobj::data_size() const {
  return _internal_data_size();
}
inline void Wobj::clear_data() {
  _impl_.data_.Clear();
}
inline double Wobj::_internal_data(int index) const {
  return _impl_.data_.Get(index);
}
inline double Wobj::data(int index) const {
  // @@protoc_insertion_point(field_get:system_rtstate.Wobj.data)
  return _internal_data(index);
}
inline void Wobj::set_data(int index, double value) {
  _impl_.data_.Set(index, value);
  // @@protoc_insertion_point(field_set:system_rtstate.Wobj.data)
}
inline void Wobj::_internal_add_data(double value) {
  _impl_.data_.Add(value);
}
inline void Wobj::add_data(double value) {
  _internal_add_data(value);
  // @@protoc_insertion_point(field_add:system_rtstate.Wobj.data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
Wobj::_internal_data() const {
  return _impl_.data_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
Wobj::data() const {
  // @@protoc_insertion_point(field_list:system_rtstate.Wobj.data)
  return _internal_data();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
Wobj::_internal_mutable_data() {
  return &_impl_.data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
Wobj::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:system_rtstate.Wobj.data)
  return _internal_mutable_data();
}

// -------------------------------------------------------------------

// Load

// string load_name = 1;
inline void Load::clear_load_name() {
  _impl_.load_name_.ClearToEmpty();
}
inline const std::string& Load::load_name() const {
  // @@protoc_insertion_point(field_get:system_rtstate.Load.load_name)
  return _internal_load_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Load::set_load_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.load_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:system_rtstate.Load.load_name)
}
inline std::string* Load::mutable_load_name() {
  std::string* _s = _internal_mutable_load_name();
  // @@protoc_insertion_point(field_mutable:system_rtstate.Load.load_name)
  return _s;
}
inline const std::string& Load::_internal_load_name() const {
  return _impl_.load_name_.Get();
}
inline void Load::_internal_set_load_name(const std::string& value) {
  
  _impl_.load_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Load::_internal_mutable_load_name() {
  
  return _impl_.load_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Load::release_load_name() {
  // @@protoc_insertion_point(field_release:system_rtstate.Load.load_name)
  return _impl_.load_name_.Release();
}
inline void Load::set_allocated_load_name(std::string* load_name) {
  if (load_name != nullptr) {
    
  } else {
    
  }
  _impl_.load_name_.SetAllocated(load_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.load_name_.IsDefault()) {
    _impl_.load_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:system_rtstate.Load.load_name)
}

// repeated double data = 2;
inline int Load::_internal_data_size() const {
  return _impl_.data_.size();
}
inline int Load::data_size() const {
  return _internal_data_size();
}
inline void Load::clear_data() {
  _impl_.data_.Clear();
}
inline double Load::_internal_data(int index) const {
  return _impl_.data_.Get(index);
}
inline double Load::data(int index) const {
  // @@protoc_insertion_point(field_get:system_rtstate.Load.data)
  return _internal_data(index);
}
inline void Load::set_data(int index, double value) {
  _impl_.data_.Set(index, value);
  // @@protoc_insertion_point(field_set:system_rtstate.Load.data)
}
inline void Load::_internal_add_data(double value) {
  _impl_.data_.Add(value);
}
inline void Load::add_data(double value) {
  _internal_add_data(value);
  // @@protoc_insertion_point(field_add:system_rtstate.Load.data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
Load::_internal_data() const {
  return _impl_.data_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
Load::data() const {
  // @@protoc_insertion_point(field_list:system_rtstate.Load.data)
  return _internal_data();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
Load::_internal_mutable_data() {
  return &_impl_.data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
Load::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:system_rtstate.Load.data)
  return _internal_mutable_data();
}

// -------------------------------------------------------------------

// Point

// string point_name = 1;
inline void Point::clear_point_name() {
  _impl_.point_name_.ClearToEmpty();
}
inline const std::string& Point::point_name() const {
  // @@protoc_insertion_point(field_get:system_rtstate.Point.point_name)
  return _internal_point_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Point::set_point_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.point_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:system_rtstate.Point.point_name)
}
inline std::string* Point::mutable_point_name() {
  std::string* _s = _internal_mutable_point_name();
  // @@protoc_insertion_point(field_mutable:system_rtstate.Point.point_name)
  return _s;
}
inline const std::string& Point::_internal_point_name() const {
  return _impl_.point_name_.Get();
}
inline void Point::_internal_set_point_name(const std::string& value) {
  
  _impl_.point_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Point::_internal_mutable_point_name() {
  
  return _impl_.point_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Point::release_point_name() {
  // @@protoc_insertion_point(field_release:system_rtstate.Point.point_name)
  return _impl_.point_name_.Release();
}
inline void Point::set_allocated_point_name(std::string* point_name) {
  if (point_name != nullptr) {
    
  } else {
    
  }
  _impl_.point_name_.SetAllocated(point_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.point_name_.IsDefault()) {
    _impl_.point_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:system_rtstate.Point.point_name)
}

// .system_rtstate.Tool tool = 2;
inline bool Point::_internal_has_tool() const {
  return this != internal_default_instance() && _impl_.tool_ != nullptr;
}
inline bool Point::has_tool() const {
  return _internal_has_tool();
}
inline void Point::clear_tool() {
  if (GetArenaForAllocation() == nullptr && _impl_.tool_ != nullptr) {
    delete _impl_.tool_;
  }
  _impl_.tool_ = nullptr;
}
inline const ::system_rtstate::Tool& Point::_internal_tool() const {
  const ::system_rtstate::Tool* p = _impl_.tool_;
  return p != nullptr ? *p : reinterpret_cast<const ::system_rtstate::Tool&>(
      ::system_rtstate::_Tool_default_instance_);
}
inline const ::system_rtstate::Tool& Point::tool() const {
  // @@protoc_insertion_point(field_get:system_rtstate.Point.tool)
  return _internal_tool();
}
inline void Point::unsafe_arena_set_allocated_tool(
    ::system_rtstate::Tool* tool) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tool_);
  }
  _impl_.tool_ = tool;
  if (tool) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:system_rtstate.Point.tool)
}
inline ::system_rtstate::Tool* Point::release_tool() {
  
  ::system_rtstate::Tool* temp = _impl_.tool_;
  _impl_.tool_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::system_rtstate::Tool* Point::unsafe_arena_release_tool() {
  // @@protoc_insertion_point(field_release:system_rtstate.Point.tool)
  
  ::system_rtstate::Tool* temp = _impl_.tool_;
  _impl_.tool_ = nullptr;
  return temp;
}
inline ::system_rtstate::Tool* Point::_internal_mutable_tool() {
  
  if (_impl_.tool_ == nullptr) {
    auto* p = CreateMaybeMessage<::system_rtstate::Tool>(GetArenaForAllocation());
    _impl_.tool_ = p;
  }
  return _impl_.tool_;
}
inline ::system_rtstate::Tool* Point::mutable_tool() {
  ::system_rtstate::Tool* _msg = _internal_mutable_tool();
  // @@protoc_insertion_point(field_mutable:system_rtstate.Point.tool)
  return _msg;
}
inline void Point::set_allocated_tool(::system_rtstate::Tool* tool) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tool_;
  }
  if (tool) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tool);
    if (message_arena != submessage_arena) {
      tool = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tool, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.tool_ = tool;
  // @@protoc_insertion_point(field_set_allocated:system_rtstate.Point.tool)
}

// .system_rtstate.Wobj wobj = 3;
inline bool Point::_internal_has_wobj() const {
  return this != internal_default_instance() && _impl_.wobj_ != nullptr;
}
inline bool Point::has_wobj() const {
  return _internal_has_wobj();
}
inline void Point::clear_wobj() {
  if (GetArenaForAllocation() == nullptr && _impl_.wobj_ != nullptr) {
    delete _impl_.wobj_;
  }
  _impl_.wobj_ = nullptr;
}
inline const ::system_rtstate::Wobj& Point::_internal_wobj() const {
  const ::system_rtstate::Wobj* p = _impl_.wobj_;
  return p != nullptr ? *p : reinterpret_cast<const ::system_rtstate::Wobj&>(
      ::system_rtstate::_Wobj_default_instance_);
}
inline const ::system_rtstate::Wobj& Point::wobj() const {
  // @@protoc_insertion_point(field_get:system_rtstate.Point.wobj)
  return _internal_wobj();
}
inline void Point::unsafe_arena_set_allocated_wobj(
    ::system_rtstate::Wobj* wobj) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.wobj_);
  }
  _impl_.wobj_ = wobj;
  if (wobj) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:system_rtstate.Point.wobj)
}
inline ::system_rtstate::Wobj* Point::release_wobj() {
  
  ::system_rtstate::Wobj* temp = _impl_.wobj_;
  _impl_.wobj_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::system_rtstate::Wobj* Point::unsafe_arena_release_wobj() {
  // @@protoc_insertion_point(field_release:system_rtstate.Point.wobj)
  
  ::system_rtstate::Wobj* temp = _impl_.wobj_;
  _impl_.wobj_ = nullptr;
  return temp;
}
inline ::system_rtstate::Wobj* Point::_internal_mutable_wobj() {
  
  if (_impl_.wobj_ == nullptr) {
    auto* p = CreateMaybeMessage<::system_rtstate::Wobj>(GetArenaForAllocation());
    _impl_.wobj_ = p;
  }
  return _impl_.wobj_;
}
inline ::system_rtstate::Wobj* Point::mutable_wobj() {
  ::system_rtstate::Wobj* _msg = _internal_mutable_wobj();
  // @@protoc_insertion_point(field_mutable:system_rtstate.Point.wobj)
  return _msg;
}
inline void Point::set_allocated_wobj(::system_rtstate::Wobj* wobj) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.wobj_;
  }
  if (wobj) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(wobj);
    if (message_arena != submessage_arena) {
      wobj = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wobj, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.wobj_ = wobj;
  // @@protoc_insertion_point(field_set_allocated:system_rtstate.Point.wobj)
}

// repeated double robottarget = 4;
inline int Point::_internal_robottarget_size() const {
  return _impl_.robottarget_.size();
}
inline int Point::robottarget_size() const {
  return _internal_robottarget_size();
}
inline void Point::clear_robottarget() {
  _impl_.robottarget_.Clear();
}
inline double Point::_internal_robottarget(int index) const {
  return _impl_.robottarget_.Get(index);
}
inline double Point::robottarget(int index) const {
  // @@protoc_insertion_point(field_get:system_rtstate.Point.robottarget)
  return _internal_robottarget(index);
}
inline void Point::set_robottarget(int index, double value) {
  _impl_.robottarget_.Set(index, value);
  // @@protoc_insertion_point(field_set:system_rtstate.Point.robottarget)
}
inline void Point::_internal_add_robottarget(double value) {
  _impl_.robottarget_.Add(value);
}
inline void Point::add_robottarget(double value) {
  _internal_add_robottarget(value);
  // @@protoc_insertion_point(field_add:system_rtstate.Point.robottarget)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
Point::_internal_robottarget() const {
  return _impl_.robottarget_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
Point::robottarget() const {
  // @@protoc_insertion_point(field_list:system_rtstate.Point.robottarget)
  return _internal_robottarget();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
Point::_internal_mutable_robottarget() {
  return &_impl_.robottarget_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
Point::mutable_robottarget() {
  // @@protoc_insertion_point(field_mutable_list:system_rtstate.Point.robottarget)
  return _internal_mutable_robottarget();
}

// repeated double jointtarget = 5;
inline int Point::_internal_jointtarget_size() const {
  return _impl_.jointtarget_.size();
}
inline int Point::jointtarget_size() const {
  return _internal_jointtarget_size();
}
inline void Point::clear_jointtarget() {
  _impl_.jointtarget_.Clear();
}
inline double Point::_internal_jointtarget(int index) const {
  return _impl_.jointtarget_.Get(index);
}
inline double Point::jointtarget(int index) const {
  // @@protoc_insertion_point(field_get:system_rtstate.Point.jointtarget)
  return _internal_jointtarget(index);
}
inline void Point::set_jointtarget(int index, double value) {
  _impl_.jointtarget_.Set(index, value);
  // @@protoc_insertion_point(field_set:system_rtstate.Point.jointtarget)
}
inline void Point::_internal_add_jointtarget(double value) {
  _impl_.jointtarget_.Add(value);
}
inline void Point::add_jointtarget(double value) {
  _internal_add_jointtarget(value);
  // @@protoc_insertion_point(field_add:system_rtstate.Point.jointtarget)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
Point::_internal_jointtarget() const {
  return _impl_.jointtarget_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
Point::jointtarget() const {
  // @@protoc_insertion_point(field_list:system_rtstate.Point.jointtarget)
  return _internal_jointtarget();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
Point::_internal_mutable_jointtarget() {
  return &_impl_.jointtarget_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
Point::mutable_jointtarget() {
  // @@protoc_insertion_point(field_mutable_list:system_rtstate.Point.jointtarget)
  return _internal_mutable_jointtarget();
}

// -------------------------------------------------------------------

// Model

// string model_name = 1;
inline void Model::clear_model_name() {
  _impl_.model_name_.ClearToEmpty();
}
inline const std::string& Model::model_name() const {
  // @@protoc_insertion_point(field_get:system_rtstate.Model.model_name)
  return _internal_model_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Model::set_model_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:system_rtstate.Model.model_name)
}
inline std::string* Model::mutable_model_name() {
  std::string* _s = _internal_mutable_model_name();
  // @@protoc_insertion_point(field_mutable:system_rtstate.Model.model_name)
  return _s;
}
inline const std::string& Model::_internal_model_name() const {
  return _impl_.model_name_.Get();
}
inline void Model::_internal_set_model_name(const std::string& value) {
  
  _impl_.model_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Model::_internal_mutable_model_name() {
  
  return _impl_.model_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Model::release_model_name() {
  // @@protoc_insertion_point(field_release:system_rtstate.Model.model_name)
  return _impl_.model_name_.Release();
}
inline void Model::set_allocated_model_name(std::string* model_name) {
  if (model_name != nullptr) {
    
  } else {
    
  }
  _impl_.model_name_.SetAllocated(model_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_name_.IsDefault()) {
    _impl_.model_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:system_rtstate.Model.model_name)
}

// string model_type = 2;
inline void Model::clear_model_type() {
  _impl_.model_type_.ClearToEmpty();
}
inline const std::string& Model::model_type() const {
  // @@protoc_insertion_point(field_get:system_rtstate.Model.model_type)
  return _internal_model_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Model::set_model_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:system_rtstate.Model.model_type)
}
inline std::string* Model::mutable_model_type() {
  std::string* _s = _internal_mutable_model_type();
  // @@protoc_insertion_point(field_mutable:system_rtstate.Model.model_type)
  return _s;
}
inline const std::string& Model::_internal_model_type() const {
  return _impl_.model_type_.Get();
}
inline void Model::_internal_set_model_type(const std::string& value) {
  
  _impl_.model_type_.Set(value, GetArenaForAllocation());
}
inline std::string* Model::_internal_mutable_model_type() {
  
  return _impl_.model_type_.Mutable(GetArenaForAllocation());
}
inline std::string* Model::release_model_type() {
  // @@protoc_insertion_point(field_release:system_rtstate.Model.model_type)
  return _impl_.model_type_.Release();
}
inline void Model::set_allocated_model_type(std::string* model_type) {
  if (model_type != nullptr) {
    
  } else {
    
  }
  _impl_.model_type_.SetAllocated(model_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_type_.IsDefault()) {
    _impl_.model_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:system_rtstate.Model.model_type)
}

// repeated .system_rtstate.Joint joint = 3;
inline int Model::_internal_joint_size() const {
  return _impl_.joint_.size();
}
inline int Model::joint_size() const {
  return _internal_joint_size();
}
inline void Model::clear_joint() {
  _impl_.joint_.Clear();
}
inline ::system_rtstate::Joint* Model::mutable_joint(int index) {
  // @@protoc_insertion_point(field_mutable:system_rtstate.Model.joint)
  return _impl_.joint_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_rtstate::Joint >*
Model::mutable_joint() {
  // @@protoc_insertion_point(field_mutable_list:system_rtstate.Model.joint)
  return &_impl_.joint_;
}
inline const ::system_rtstate::Joint& Model::_internal_joint(int index) const {
  return _impl_.joint_.Get(index);
}
inline const ::system_rtstate::Joint& Model::joint(int index) const {
  // @@protoc_insertion_point(field_get:system_rtstate.Model.joint)
  return _internal_joint(index);
}
inline ::system_rtstate::Joint* Model::_internal_add_joint() {
  return _impl_.joint_.Add();
}
inline ::system_rtstate::Joint* Model::add_joint() {
  ::system_rtstate::Joint* _add = _internal_add_joint();
  // @@protoc_insertion_point(field_add:system_rtstate.Model.joint)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_rtstate::Joint >&
Model::joint() const {
  // @@protoc_insertion_point(field_list:system_rtstate.Model.joint)
  return _impl_.joint_;
}

// .system_rtstate.Point current_point = 4;
inline bool Model::_internal_has_current_point() const {
  return this != internal_default_instance() && _impl_.current_point_ != nullptr;
}
inline bool Model::has_current_point() const {
  return _internal_has_current_point();
}
inline void Model::clear_current_point() {
  if (GetArenaForAllocation() == nullptr && _impl_.current_point_ != nullptr) {
    delete _impl_.current_point_;
  }
  _impl_.current_point_ = nullptr;
}
inline const ::system_rtstate::Point& Model::_internal_current_point() const {
  const ::system_rtstate::Point* p = _impl_.current_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::system_rtstate::Point&>(
      ::system_rtstate::_Point_default_instance_);
}
inline const ::system_rtstate::Point& Model::current_point() const {
  // @@protoc_insertion_point(field_get:system_rtstate.Model.current_point)
  return _internal_current_point();
}
inline void Model::unsafe_arena_set_allocated_current_point(
    ::system_rtstate::Point* current_point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.current_point_);
  }
  _impl_.current_point_ = current_point;
  if (current_point) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:system_rtstate.Model.current_point)
}
inline ::system_rtstate::Point* Model::release_current_point() {
  
  ::system_rtstate::Point* temp = _impl_.current_point_;
  _impl_.current_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::system_rtstate::Point* Model::unsafe_arena_release_current_point() {
  // @@protoc_insertion_point(field_release:system_rtstate.Model.current_point)
  
  ::system_rtstate::Point* temp = _impl_.current_point_;
  _impl_.current_point_ = nullptr;
  return temp;
}
inline ::system_rtstate::Point* Model::_internal_mutable_current_point() {
  
  if (_impl_.current_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::system_rtstate::Point>(GetArenaForAllocation());
    _impl_.current_point_ = p;
  }
  return _impl_.current_point_;
}
inline ::system_rtstate::Point* Model::mutable_current_point() {
  ::system_rtstate::Point* _msg = _internal_mutable_current_point();
  // @@protoc_insertion_point(field_mutable:system_rtstate.Model.current_point)
  return _msg;
}
inline void Model::set_allocated_current_point(::system_rtstate::Point* current_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.current_point_;
  }
  if (current_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(current_point);
    if (message_arena != submessage_arena) {
      current_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, current_point, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.current_point_ = current_point;
  // @@protoc_insertion_point(field_set_allocated:system_rtstate.Model.current_point)
}

// int32 error_code = 5;
inline void Model::clear_error_code() {
  _impl_.error_code_ = 0;
}
inline int32_t Model::_internal_error_code() const {
  return _impl_.error_code_;
}
inline int32_t Model::error_code() const {
  // @@protoc_insertion_point(field_get:system_rtstate.Model.error_code)
  return _internal_error_code();
}
inline void Model::_internal_set_error_code(int32_t value) {
  
  _impl_.error_code_ = value;
}
inline void Model::set_error_code(int32_t value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:system_rtstate.Model.error_code)
}

// string error_msg = 6;
inline void Model::clear_error_msg() {
  _impl_.error_msg_.ClearToEmpty();
}
inline const std::string& Model::error_msg() const {
  // @@protoc_insertion_point(field_get:system_rtstate.Model.error_msg)
  return _internal_error_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Model::set_error_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:system_rtstate.Model.error_msg)
}
inline std::string* Model::mutable_error_msg() {
  std::string* _s = _internal_mutable_error_msg();
  // @@protoc_insertion_point(field_mutable:system_rtstate.Model.error_msg)
  return _s;
}
inline const std::string& Model::_internal_error_msg() const {
  return _impl_.error_msg_.Get();
}
inline void Model::_internal_set_error_msg(const std::string& value) {
  
  _impl_.error_msg_.Set(value, GetArenaForAllocation());
}
inline std::string* Model::_internal_mutable_error_msg() {
  
  return _impl_.error_msg_.Mutable(GetArenaForAllocation());
}
inline std::string* Model::release_error_msg() {
  // @@protoc_insertion_point(field_release:system_rtstate.Model.error_msg)
  return _impl_.error_msg_.Release();
}
inline void Model::set_allocated_error_msg(std::string* error_msg) {
  if (error_msg != nullptr) {
    
  } else {
    
  }
  _impl_.error_msg_.SetAllocated(error_msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_msg_.IsDefault()) {
    _impl_.error_msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:system_rtstate.Model.error_msg)
}

// int32 model_state = 7;
inline void Model::clear_model_state() {
  _impl_.model_state_ = 0;
}
inline int32_t Model::_internal_model_state() const {
  return _impl_.model_state_;
}
inline int32_t Model::model_state() const {
  // @@protoc_insertion_point(field_get:system_rtstate.Model.model_state)
  return _internal_model_state();
}
inline void Model::_internal_set_model_state(int32_t value) {
  
  _impl_.model_state_ = value;
}
inline void Model::set_model_state(int32_t value) {
  _internal_set_model_state(value);
  // @@protoc_insertion_point(field_set:system_rtstate.Model.model_state)
}

// double model_time_rate = 8;
inline void Model::clear_model_time_rate() {
  _impl_.model_time_rate_ = 0;
}
inline double Model::_internal_model_time_rate() const {
  return _impl_.model_time_rate_;
}
inline double Model::model_time_rate() const {
  // @@protoc_insertion_point(field_get:system_rtstate.Model.model_time_rate)
  return _internal_model_time_rate();
}
inline void Model::_internal_set_model_time_rate(double value) {
  
  _impl_.model_time_rate_ = value;
}
inline void Model::set_model_time_rate(double value) {
  _internal_set_model_time_rate(value);
  // @@protoc_insertion_point(field_set:system_rtstate.Model.model_time_rate)
}

// string current_func_name = 9;
inline void Model::clear_current_func_name() {
  _impl_.current_func_name_.ClearToEmpty();
}
inline const std::string& Model::current_func_name() const {
  // @@protoc_insertion_point(field_get:system_rtstate.Model.current_func_name)
  return _internal_current_func_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Model::set_current_func_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.current_func_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:system_rtstate.Model.current_func_name)
}
inline std::string* Model::mutable_current_func_name() {
  std::string* _s = _internal_mutable_current_func_name();
  // @@protoc_insertion_point(field_mutable:system_rtstate.Model.current_func_name)
  return _s;
}
inline const std::string& Model::_internal_current_func_name() const {
  return _impl_.current_func_name_.Get();
}
inline void Model::_internal_set_current_func_name(const std::string& value) {
  
  _impl_.current_func_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Model::_internal_mutable_current_func_name() {
  
  return _impl_.current_func_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Model::release_current_func_name() {
  // @@protoc_insertion_point(field_release:system_rtstate.Model.current_func_name)
  return _impl_.current_func_name_.Release();
}
inline void Model::set_allocated_current_func_name(std::string* current_func_name) {
  if (current_func_name != nullptr) {
    
  } else {
    
  }
  _impl_.current_func_name_.SetAllocated(current_func_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.current_func_name_.IsDefault()) {
    _impl_.current_func_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:system_rtstate.Model.current_func_name)
}

// string current_func_info = 10;
inline void Model::clear_current_func_info() {
  _impl_.current_func_info_.ClearToEmpty();
}
inline const std::string& Model::current_func_info() const {
  // @@protoc_insertion_point(field_get:system_rtstate.Model.current_func_info)
  return _internal_current_func_info();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Model::set_current_func_info(ArgT0&& arg0, ArgT... args) {
 
 _impl_.current_func_info_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:system_rtstate.Model.current_func_info)
}
inline std::string* Model::mutable_current_func_info() {
  std::string* _s = _internal_mutable_current_func_info();
  // @@protoc_insertion_point(field_mutable:system_rtstate.Model.current_func_info)
  return _s;
}
inline const std::string& Model::_internal_current_func_info() const {
  return _impl_.current_func_info_.Get();
}
inline void Model::_internal_set_current_func_info(const std::string& value) {
  
  _impl_.current_func_info_.Set(value, GetArenaForAllocation());
}
inline std::string* Model::_internal_mutable_current_func_info() {
  
  return _impl_.current_func_info_.Mutable(GetArenaForAllocation());
}
inline std::string* Model::release_current_func_info() {
  // @@protoc_insertion_point(field_release:system_rtstate.Model.current_func_info)
  return _impl_.current_func_info_.Release();
}
inline void Model::set_allocated_current_func_info(std::string* current_func_info) {
  if (current_func_info != nullptr) {
    
  } else {
    
  }
  _impl_.current_func_info_.SetAllocated(current_func_info, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.current_func_info_.IsDefault()) {
    _impl_.current_func_info_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:system_rtstate.Model.current_func_info)
}

// int32 func_count = 11;
inline void Model::clear_func_count() {
  _impl_.func_count_ = 0;
}
inline int32_t Model::_internal_func_count() const {
  return _impl_.func_count_;
}
inline int32_t Model::func_count() const {
  // @@protoc_insertion_point(field_get:system_rtstate.Model.func_count)
  return _internal_func_count();
}
inline void Model::_internal_set_func_count(int32_t value) {
  
  _impl_.func_count_ = value;
}
inline void Model::set_func_count(int32_t value) {
  _internal_set_func_count(value);
  // @@protoc_insertion_point(field_set:system_rtstate.Model.func_count)
}

// string info_msg = 12;
inline void Model::clear_info_msg() {
  _impl_.info_msg_.ClearToEmpty();
}
inline const std::string& Model::info_msg() const {
  // @@protoc_insertion_point(field_get:system_rtstate.Model.info_msg)
  return _internal_info_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Model::set_info_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.info_msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:system_rtstate.Model.info_msg)
}
inline std::string* Model::mutable_info_msg() {
  std::string* _s = _internal_mutable_info_msg();
  // @@protoc_insertion_point(field_mutable:system_rtstate.Model.info_msg)
  return _s;
}
inline const std::string& Model::_internal_info_msg() const {
  return _impl_.info_msg_.Get();
}
inline void Model::_internal_set_info_msg(const std::string& value) {
  
  _impl_.info_msg_.Set(value, GetArenaForAllocation());
}
inline std::string* Model::_internal_mutable_info_msg() {
  
  return _impl_.info_msg_.Mutable(GetArenaForAllocation());
}
inline std::string* Model::release_info_msg() {
  // @@protoc_insertion_point(field_release:system_rtstate.Model.info_msg)
  return _impl_.info_msg_.Release();
}
inline void Model::set_allocated_info_msg(std::string* info_msg) {
  if (info_msg != nullptr) {
    
  } else {
    
  }
  _impl_.info_msg_.SetAllocated(info_msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.info_msg_.IsDefault()) {
    _impl_.info_msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:system_rtstate.Model.info_msg)
}

// repeated double ee_pe321 = 13;
inline int Model::_internal_ee_pe321_size() const {
  return _impl_.ee_pe321_.size();
}
inline int Model::ee_pe321_size() const {
  return _internal_ee_pe321_size();
}
inline void Model::clear_ee_pe321() {
  _impl_.ee_pe321_.Clear();
}
inline double Model::_internal_ee_pe321(int index) const {
  return _impl_.ee_pe321_.Get(index);
}
inline double Model::ee_pe321(int index) const {
  // @@protoc_insertion_point(field_get:system_rtstate.Model.ee_pe321)
  return _internal_ee_pe321(index);
}
inline void Model::set_ee_pe321(int index, double value) {
  _impl_.ee_pe321_.Set(index, value);
  // @@protoc_insertion_point(field_set:system_rtstate.Model.ee_pe321)
}
inline void Model::_internal_add_ee_pe321(double value) {
  _impl_.ee_pe321_.Add(value);
}
inline void Model::add_ee_pe321(double value) {
  _internal_add_ee_pe321(value);
  // @@protoc_insertion_point(field_add:system_rtstate.Model.ee_pe321)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
Model::_internal_ee_pe321() const {
  return _impl_.ee_pe321_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
Model::ee_pe321() const {
  // @@protoc_insertion_point(field_list:system_rtstate.Model.ee_pe321)
  return _internal_ee_pe321();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
Model::_internal_mutable_ee_pe321() {
  return &_impl_.ee_pe321_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
Model::mutable_ee_pe321() {
  // @@protoc_insertion_point(field_mutable_list:system_rtstate.Model.ee_pe321)
  return _internal_mutable_ee_pe321();
}

// -------------------------------------------------------------------

// SystemRtState

// .system_rtstate.Header head = 1;
inline bool SystemRtState::_internal_has_head() const {
  return this != internal_default_instance() && _impl_.head_ != nullptr;
}
inline bool SystemRtState::has_head() const {
  return _internal_has_head();
}
inline void SystemRtState::clear_head() {
  if (GetArenaForAllocation() == nullptr && _impl_.head_ != nullptr) {
    delete _impl_.head_;
  }
  _impl_.head_ = nullptr;
}
inline const ::system_rtstate::Header& SystemRtState::_internal_head() const {
  const ::system_rtstate::Header* p = _impl_.head_;
  return p != nullptr ? *p : reinterpret_cast<const ::system_rtstate::Header&>(
      ::system_rtstate::_Header_default_instance_);
}
inline const ::system_rtstate::Header& SystemRtState::head() const {
  // @@protoc_insertion_point(field_get:system_rtstate.SystemRtState.head)
  return _internal_head();
}
inline void SystemRtState::unsafe_arena_set_allocated_head(
    ::system_rtstate::Header* head) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.head_);
  }
  _impl_.head_ = head;
  if (head) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:system_rtstate.SystemRtState.head)
}
inline ::system_rtstate::Header* SystemRtState::release_head() {
  
  ::system_rtstate::Header* temp = _impl_.head_;
  _impl_.head_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::system_rtstate::Header* SystemRtState::unsafe_arena_release_head() {
  // @@protoc_insertion_point(field_release:system_rtstate.SystemRtState.head)
  
  ::system_rtstate::Header* temp = _impl_.head_;
  _impl_.head_ = nullptr;
  return temp;
}
inline ::system_rtstate::Header* SystemRtState::_internal_mutable_head() {
  
  if (_impl_.head_ == nullptr) {
    auto* p = CreateMaybeMessage<::system_rtstate::Header>(GetArenaForAllocation());
    _impl_.head_ = p;
  }
  return _impl_.head_;
}
inline ::system_rtstate::Header* SystemRtState::mutable_head() {
  ::system_rtstate::Header* _msg = _internal_mutable_head();
  // @@protoc_insertion_point(field_mutable:system_rtstate.SystemRtState.head)
  return _msg;
}
inline void SystemRtState::set_allocated_head(::system_rtstate::Header* head) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.head_;
  }
  if (head) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(head);
    if (message_arena != submessage_arena) {
      head = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, head, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.head_ = head;
  // @@protoc_insertion_point(field_set_allocated:system_rtstate.SystemRtState.head)
}

// bool system_running_state = 2;
inline void SystemRtState::clear_system_running_state() {
  _impl_.system_running_state_ = false;
}
inline bool SystemRtState::_internal_system_running_state() const {
  return _impl_.system_running_state_;
}
inline bool SystemRtState::system_running_state() const {
  // @@protoc_insertion_point(field_get:system_rtstate.SystemRtState.system_running_state)
  return _internal_system_running_state();
}
inline void SystemRtState::_internal_set_system_running_state(bool value) {
  
  _impl_.system_running_state_ = value;
}
inline void SystemRtState::set_system_running_state(bool value) {
  _internal_set_system_running_state(value);
  // @@protoc_insertion_point(field_set:system_rtstate.SystemRtState.system_running_state)
}

// repeated .system_rtstate.Model model = 3;
inline int SystemRtState::_internal_model_size() const {
  return _impl_.model_.size();
}
inline int SystemRtState::model_size() const {
  return _internal_model_size();
}
inline void SystemRtState::clear_model() {
  _impl_.model_.Clear();
}
inline ::system_rtstate::Model* SystemRtState::mutable_model(int index) {
  // @@protoc_insertion_point(field_mutable:system_rtstate.SystemRtState.model)
  return _impl_.model_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_rtstate::Model >*
SystemRtState::mutable_model() {
  // @@protoc_insertion_point(field_mutable_list:system_rtstate.SystemRtState.model)
  return &_impl_.model_;
}
inline const ::system_rtstate::Model& SystemRtState::_internal_model(int index) const {
  return _impl_.model_.Get(index);
}
inline const ::system_rtstate::Model& SystemRtState::model(int index) const {
  // @@protoc_insertion_point(field_get:system_rtstate.SystemRtState.model)
  return _internal_model(index);
}
inline ::system_rtstate::Model* SystemRtState::_internal_add_model() {
  return _impl_.model_.Add();
}
inline ::system_rtstate::Model* SystemRtState::add_model() {
  ::system_rtstate::Model* _add = _internal_add_model();
  // @@protoc_insertion_point(field_add:system_rtstate.SystemRtState.model)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::system_rtstate::Model >&
SystemRtState::model() const {
  // @@protoc_insertion_point(field_list:system_rtstate.SystemRtState.model)
  return _impl_.model_;
}

// .system_rtstate.Controller controller = 4;
inline bool SystemRtState::_internal_has_controller() const {
  return this != internal_default_instance() && _impl_.controller_ != nullptr;
}
inline bool SystemRtState::has_controller() const {
  return _internal_has_controller();
}
inline void SystemRtState::clear_controller() {
  if (GetArenaForAllocation() == nullptr && _impl_.controller_ != nullptr) {
    delete _impl_.controller_;
  }
  _impl_.controller_ = nullptr;
}
inline const ::system_rtstate::Controller& SystemRtState::_internal_controller() const {
  const ::system_rtstate::Controller* p = _impl_.controller_;
  return p != nullptr ? *p : reinterpret_cast<const ::system_rtstate::Controller&>(
      ::system_rtstate::_Controller_default_instance_);
}
inline const ::system_rtstate::Controller& SystemRtState::controller() const {
  // @@protoc_insertion_point(field_get:system_rtstate.SystemRtState.controller)
  return _internal_controller();
}
inline void SystemRtState::unsafe_arena_set_allocated_controller(
    ::system_rtstate::Controller* controller) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controller_);
  }
  _impl_.controller_ = controller;
  if (controller) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:system_rtstate.SystemRtState.controller)
}
inline ::system_rtstate::Controller* SystemRtState::release_controller() {
  
  ::system_rtstate::Controller* temp = _impl_.controller_;
  _impl_.controller_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::system_rtstate::Controller* SystemRtState::unsafe_arena_release_controller() {
  // @@protoc_insertion_point(field_release:system_rtstate.SystemRtState.controller)
  
  ::system_rtstate::Controller* temp = _impl_.controller_;
  _impl_.controller_ = nullptr;
  return temp;
}
inline ::system_rtstate::Controller* SystemRtState::_internal_mutable_controller() {
  
  if (_impl_.controller_ == nullptr) {
    auto* p = CreateMaybeMessage<::system_rtstate::Controller>(GetArenaForAllocation());
    _impl_.controller_ = p;
  }
  return _impl_.controller_;
}
inline ::system_rtstate::Controller* SystemRtState::mutable_controller() {
  ::system_rtstate::Controller* _msg = _internal_mutable_controller();
  // @@protoc_insertion_point(field_mutable:system_rtstate.SystemRtState.controller)
  return _msg;
}
inline void SystemRtState::set_allocated_controller(::system_rtstate::Controller* controller) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.controller_;
  }
  if (controller) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(controller);
    if (message_arena != submessage_arena) {
      controller = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, controller, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.controller_ = controller;
  // @@protoc_insertion_point(field_set_allocated:system_rtstate.SystemRtState.controller)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace system_rtstate

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_overall_5fsystem_5frtstate_2eproto

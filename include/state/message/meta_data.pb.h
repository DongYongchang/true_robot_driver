// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: meta_data.proto

#ifndef PROTOBUF_USE_DLLS
#define PROTOBUF_USE_DLLS

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_USE_DLLS


PROTOBUF_NAMESPACE_OPEN
namespace internal {
    class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_meta_5fdata_2eproto {
    static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_meta_5fdata_2eproto;
namespace meta_data {
    class MetaData;
    struct MetaDataDefaultTypeInternal;
    extern MetaDataDefaultTypeInternal _MetaData_default_instance_;
}  // namespace meta_data
PROTOBUF_NAMESPACE_OPEN
template<> ::meta_data::MetaData* Arena::CreateMaybeMessage<::meta_data::MetaData>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace meta_data {

    // ===================================================================

    class MetaData final :
        public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:meta_data.MetaData) */ {
    public:
        inline MetaData() : MetaData(nullptr) {}
        ~MetaData() override;
        explicit PROTOBUF_CONSTEXPR MetaData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

        MetaData(const MetaData& from);
        MetaData(MetaData&& from) noexcept
            : MetaData() {
            *this = ::std::move(from);
        }

        inline MetaData& operator=(const MetaData& from) {
            CopyFrom(from);
            return *this;
        }
        inline MetaData& operator=(MetaData&& from) noexcept {
            if (this == &from) return *this;
            if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
                && GetOwningArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
                ) {
                InternalSwap(&from);
            }
            else {
                CopyFrom(from);
            }
            return *this;
        }

        static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
            return GetDescriptor();
        }
        static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
            return default_instance().GetMetadata().descriptor;
        }
        static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
            return default_instance().GetMetadata().reflection;
        }
        static const MetaData& default_instance() {
            return *internal_default_instance();
        }
        static inline const MetaData* internal_default_instance() {
            return reinterpret_cast<const MetaData*>(
                &_MetaData_default_instance_);
        }
        static constexpr int kIndexInFileMessages =
            0;

        friend void swap(MetaData& a, MetaData& b) {
            a.Swap(&b);
        }
        inline void Swap(MetaData* other) {
            if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
            if (GetOwningArena() != nullptr &&
                GetOwningArena() == other->GetOwningArena()) {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
            if (GetOwningArena() == other->GetOwningArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
                InternalSwap(other);
            }
            else {
                ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
            }
            }
        void UnsafeArenaSwap(MetaData * other) {
            if (other == this) return;
            GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
            InternalSwap(other);
        }

        // implements Message ----------------------------------------------

        MetaData* New(::PROTOBUF_NAMESPACE_ID::Arena * arena = nullptr) const final {
            return CreateMaybeMessage<MetaData>(arena);
        }
        using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
        void CopyFrom(const MetaData & from);
        using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
        void MergeFrom(const MetaData & from) {
            MetaData::MergeImpl(*this, from);
        }
    private:
        static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message & to_msg, const ::PROTOBUF_NAMESPACE_ID::Message & from_msg);
    public:
        PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
        bool IsInitialized() const final;

        size_t ByteSizeLong() const final;
        const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext * ctx) final;
        uint8_t* _InternalSerialize(
            uint8_t * target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream * stream) const final;
        int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

    private:
        void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena * arena, bool is_message_owned);
        void SharedDtor();
        void SetCachedSize(int size) const final;
        void InternalSwap(MetaData * other);

    private:
        friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
        static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
            return "meta_data.MetaData";
        }
    protected:
        explicit MetaData(::PROTOBUF_NAMESPACE_ID::Arena * arena,
            bool is_message_owned = false);
    public:

        static const ClassData _class_data_;
        const ::PROTOBUF_NAMESPACE_ID::Message::ClassData* GetClassData() const final;

        ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        enum : int {
            kProtoTypeNameFieldNumber = 1,
            kSourceNodeNameFieldNumber = 2,
        };
        // string proto_type_name = 1;
        void clear_proto_type_name();
        const std::string& proto_type_name() const;
        template <typename ArgT0 = const std::string&, typename... ArgT>
        void set_proto_type_name(ArgT0 && arg0, ArgT... args);
        std::string* mutable_proto_type_name();
        PROTOBUF_NODISCARD std::string* release_proto_type_name();
        void set_allocated_proto_type_name(std::string * proto_type_name);
    private:
        const std::string& _internal_proto_type_name() const;
        inline PROTOBUF_ALWAYS_INLINE void _internal_set_proto_type_name(const std::string & value);
        std::string* _internal_mutable_proto_type_name();
    public:

        // string source_node_name = 2;
        void clear_source_node_name();
        const std::string& source_node_name() const;
        template <typename ArgT0 = const std::string&, typename... ArgT>
        void set_source_node_name(ArgT0 && arg0, ArgT... args);
        std::string* mutable_source_node_name();
        PROTOBUF_NODISCARD std::string* release_source_node_name();
        void set_allocated_source_node_name(std::string * source_node_name);
    private:
        const std::string& _internal_source_node_name() const;
        inline PROTOBUF_ALWAYS_INLINE void _internal_set_source_node_name(const std::string & value);
        std::string* _internal_mutable_source_node_name();
    public:

        // @@protoc_insertion_point(class_scope:meta_data.MetaData)
    private:
        class _Internal;

        template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
        typedef void InternalArenaConstructable_;
        typedef void DestructorSkippable_;
        struct Impl_ {
            ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr proto_type_name_;
            ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_node_name_;
            mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        };
        union { Impl_ _impl_; };
        friend struct ::TableStruct_meta_5fdata_2eproto;
        };
    // ===================================================================


    // ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MetaData

// string proto_type_name = 1;
    inline void MetaData::clear_proto_type_name() {
        _impl_.proto_type_name_.ClearToEmpty();
    }
    inline const std::string& MetaData::proto_type_name() const {
        // @@protoc_insertion_point(field_get:meta_data.MetaData.proto_type_name)
        return _internal_proto_type_name();
    }
    template <typename ArgT0, typename... ArgT>
    inline PROTOBUF_ALWAYS_INLINE
        void MetaData::set_proto_type_name(ArgT0&& arg0, ArgT... args) {

        _impl_.proto_type_name_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
        // @@protoc_insertion_point(field_set:meta_data.MetaData.proto_type_name)
    }
    inline std::string* MetaData::mutable_proto_type_name() {
        std::string* _s = _internal_mutable_proto_type_name();
        // @@protoc_insertion_point(field_mutable:meta_data.MetaData.proto_type_name)
        return _s;
    }
    inline const std::string& MetaData::_internal_proto_type_name() const {
        return _impl_.proto_type_name_.Get();
    }
    inline void MetaData::_internal_set_proto_type_name(const std::string& value) {

        _impl_.proto_type_name_.Set(value, GetArenaForAllocation());
    }
    inline std::string* MetaData::_internal_mutable_proto_type_name() {

        return _impl_.proto_type_name_.Mutable(GetArenaForAllocation());
    }
    inline std::string* MetaData::release_proto_type_name() {
        // @@protoc_insertion_point(field_release:meta_data.MetaData.proto_type_name)
        return _impl_.proto_type_name_.Release();
    }
    inline void MetaData::set_allocated_proto_type_name(std::string* proto_type_name) {
        if (proto_type_name != nullptr) {

        }
        else {

        }
        _impl_.proto_type_name_.SetAllocated(proto_type_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.proto_type_name_.IsDefault()) {
            _impl_.proto_type_name_.Set("", GetArenaForAllocation());
        }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
        // @@protoc_insertion_point(field_set_allocated:meta_data.MetaData.proto_type_name)
    }

    // string source_node_name = 2;
    inline void MetaData::clear_source_node_name() {
        _impl_.source_node_name_.ClearToEmpty();
    }
    inline const std::string& MetaData::source_node_name() const {
        // @@protoc_insertion_point(field_get:meta_data.MetaData.source_node_name)
        return _internal_source_node_name();
    }
    template <typename ArgT0, typename... ArgT>
    inline PROTOBUF_ALWAYS_INLINE
        void MetaData::set_source_node_name(ArgT0&& arg0, ArgT... args) {

        _impl_.source_node_name_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
        // @@protoc_insertion_point(field_set:meta_data.MetaData.source_node_name)
    }
    inline std::string* MetaData::mutable_source_node_name() {
        std::string* _s = _internal_mutable_source_node_name();
        // @@protoc_insertion_point(field_mutable:meta_data.MetaData.source_node_name)
        return _s;
    }
    inline const std::string& MetaData::_internal_source_node_name() const {
        return _impl_.source_node_name_.Get();
    }
    inline void MetaData::_internal_set_source_node_name(const std::string& value) {

        _impl_.source_node_name_.Set(value, GetArenaForAllocation());
    }
    inline std::string* MetaData::_internal_mutable_source_node_name() {

        return _impl_.source_node_name_.Mutable(GetArenaForAllocation());
    }
    inline std::string* MetaData::release_source_node_name() {
        // @@protoc_insertion_point(field_release:meta_data.MetaData.source_node_name)
        return _impl_.source_node_name_.Release();
    }
    inline void MetaData::set_allocated_source_node_name(std::string* source_node_name) {
        if (source_node_name != nullptr) {

        }
        else {

        }
        _impl_.source_node_name_.SetAllocated(source_node_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.source_node_name_.IsDefault()) {
            _impl_.source_node_name_.Set("", GetArenaForAllocation());
        }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
        // @@protoc_insertion_point(field_set_allocated:meta_data.MetaData.source_node_name)
    }

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

    // @@protoc_insertion_point(namespace_scope)

    }  // namespace meta_data

    // @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_USE_DLLS
